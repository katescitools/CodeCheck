# This script is designed to run with Understand - CodeCheck
# Written by Jason Quinn
# 02-23-2023
import re
ERR1 = "Narrow and Wide String literal concatenated together."

def ids():
    return ('MISRA08_2-13-5', 'CPP_D021')

def name(id):
    return {
            'MISRA08_2-13-5': 'Published Standards/MISRA-C++ 2008/Narrow and wide string literals shall not be concatenated',
            'CPP_D021': 'All Checks/Language Specific/C and C++/Declarations and Definitions/Narrow and wide string literals shall not be concatenated',
            }[id]

    def detailed_description():
        return """\
<p><b>Rationale</b></p>
<p>Concatenation of wide and narrow string literals leads to undefined behaviour.</p>
<p><b>Example</b></p>
<pre>
  char n_array[] = "Hello" "World"; // Compliant
  wchar_t w_array[] = L"Hello" L"World"; // Compliant
  wchar_t mixed[] = "Hello" L"World"; // Non-compliant
</pre>
"""

def test_entity(file):
    return file.kind().check('code file, header file')

def test_language(language):
    return language == 'C++'

def check(check, file):
    lexer = None

    # Look for wchar_t set refs
    refs = file.filerefs("Set")
    for ref in refs:
        if not re.search('wchar_t', str(ref.ent().type())):
            continue

        # Initialize bools
        wide = False
        narrow = False

        # Set up lexer
        if not lexer:
            if not file.lexer():
                return
            lexer = file.lexer()
        lexeme = lexer.lexeme(ref.line(), ref.column())

        # Look for a string that starts with 'L' and one that doesn't
        while lexeme and lexeme.text() != ';':
            if lexeme.token() == "String":
                if re.match("L", lexeme.text()):
                    wide = True

                else:
                    narrow = True

            lexeme = lexeme.next(True, True)

        if wide and narrow:
            check.violation(ref.ent(), file, ref.line(), ref.column(), ERR1)
