# This script is designed to run with Understand - CodeCheck
# 7-21-21

import re

ERR1 = 'Enumeration underlying base type not explicitly defined'

# The ID for the check
def ids():
    return ('A7-2-2', 'CPP_T028')

# The short name of the check
def name(id):
    return {
        'A7-2-2': 'Published Standards/AUTOSAR/Enumeration underlying base type shall be explicitly defined',
        'CPP_T028': 'All Checks/Language Specific/C and C++/Types/Enumeration underlying base type shall be explicitly defined',
    }[id]

# The long description of the check
def detailed_description():
    return '''
<p><b>Rationale</b></p>

<p>The enumeration underlying type is implementation-defined, with the only restriction that the type must be able to represent the enumeration values. Although scoped enum will implicitly define an underlying type of int, the underlying base type of enumeration should always be explicitly defined with a type that will be large enough to store all enumerators.
</p>

<p><b>Example</b></p>

<pre>
// $Id: A7-2-2.cpp 271715 2017-03-23 10:13:51Z piotr.tanski $
#include &lt;cstdint&gt;
enum class E1 // Non-compliant
{
    E10,
    E11,
    E12
};
enum class E2 : std::uint8_t // Compliant
{
    E20,
    E21,
    E22
};
enum E3 // Non-compliant
{
    E30,
    E31,
    E32
};
enum E4 : std::uint8_t // Compliant - violating another rule
{
    E40,
    E41,
    E42
};
enum class E5 : std::uint8_t // Non-compliant - will not compile
{
    E50 = 255,
    // E5_1, // E5_1 = 256 which is outside of range of underlying type
    // std::uint8_t
    // - compilation error
    // E5_2 // E5_2 = 257 which is outside of range of underlying type
    // std::uint8_t
    // - compilation error
};
</pre>

<p><b>See also</b></p>

<p>
HIC++ v4.0 [9]: 7.2.1 Use an explicit enumeration base and ensure that it is large enough to store all enumerators
</p>
'''

# Tests the type of file
def test_entity(file):
    return file.kind().check('header file,code file')

# Optional - Return True if this check should be run on the entire project
# regardless of what files are selected. Should only be used for
# project-level checks
def test_global():
    return False

def test_language(language):
    return language == 'C++'

def check(check, file):
	for ref in file.filerefs("","~Unknown Enum", True) :
		pattern = re.compile("[enum]{1}.*%s\s*[:]{1}.*\s*\{"%ref.ent())
		if not pattern.findall(ref.ent().contents()) :
			check.violation(ref.ent(), file, ref.line(), ref.column(), ERR1)
