import re

DEF_NAME = "Variables shall not be implicitly captured in a lambda expression"

# The ID for the check 
def ids():
    return ('A5-1-2', 'CPP_V022')

# The short name of the check
def name(id):
    return {
        'A5-1-2': 'Published Standards/AUTOSAR/Variables shall not be implicitly captured in a lambda expression',
        'CPP_V022': 'All Checks/Language Specific/C and C++/Variables/Variables shall not be implicitly captured in a lambda expression',
    }[id]

# The short description of the check
def description():
    return 'Variables shall not be implicitly captured in a lambda expression.'

# The long description of the check
def detailed_description():
    return """\
<p><b>Rationale</b></p>
<p>Capturing variables explicitly helps document the intention of the author. It also allows for different variables to be explicitly captured by copy or by reference within the lambda definition.</p>
<p><b>Exception</b></p>
<p>It is allowed to implicitly capture variables with non-automatic storage duration.</p>
<p><b>Example</b></p>
<pre style="margin-top:0;padding-top:0;">
1 // $Id: A5-1-2.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $
2 #include <algorithm>
3 #include <cstdint>
4 #include <vector>
5 void Fn1(const std::vector<std::int32_t>& v)
6 {
7 std::uint64_t sum = 0;
8 std::for_each(v.begin(), v.end(), [&](std::int32_t lhs) {
9 sum += lhs;
10 }); // Non-compliant
11
12 sum = 0;
13 std::for_each(v.begin(), v.end(), [&sum](std::int32_t lhs) {
14 sum += lhs;
15 }); // Compliant
16 }
17 void Fn2()
18 {
19 constexpr std::uint8_t n = 10;
20 static std::int32_t j = 0;
21 [n]() {
22 std::int32_t array[n]; // Compliant
23 j += 1; // Compliant by exception
24 };
25 }
</pre>
<p><b>See also</b></p>
<p>HIC++ v4.0 [9]: 5.1.4 Do not capture variables implicitly in a lambda.
</p>
<p>C++ Core Guidelines [11]: F.54: If you capture this, capture all variables explicitly (no default capture).
</p>"""

# Tests the type of file
def test_entity(file):
    return file.kind().check('header file,code file')

# Optional - Return True if this check should be run on the entire project
# regardless of what files are selected. Should only be used for 
# project-level checks
def test_global():
    return False

def test_language(language):
    return language == 'C++'

def check(check, file):
    lexer = file.lexer()
    for ref in file.filerefs("","Lambda",True):
        if ref.ent():
            result = re.search('\[.+?\]', ref.ent().contents())
            for inner in ref.ent().ents("Capture,Modify","Object"):
                lex = lexer.lexeme(inner.ref().line(), inner.ref().column())
                static = False
                while lex and lex.text() != ";" and lex.text() != "}":
                    if lex.text() == "static":
                        static = True # Compliant by exception
                    lex = lex.previous()
                if not static and result:
                    if not str(inner.name()) in str(result.group()):
                        check.violation(ref.ent(), file, ref.line(), ref.column(), DEF_NAME)
