# This script is designed to run with Understand - CodeCheck
# Written by Robby Bennett
# 11-10-21


import re


ERR1 = '"%1" placed on left side of type "%2"'


def ids():
    return ('A7-1-3', 'CPP_T025')


def name(id):
    return {
        'A7-1-3': 'Published Standards/AUTOSAR/CV-qualifiers shall be placed on the right hand side of the type that is a typedef or a using name',
        'CPP_T025': 'All Checks/Language Specific/C and C++/Types/CV-qualifiers shall be placed on the right hand side of the type that is a typedef or a using name',
    }[id]


def detailed_description():
    return '''
<p><b>Rationale</b><br>
If the type is a typedef or a using name, placing const or volatile qualifier on the left hand side may result in confusion over what part of the type the qualification applies to.
</p>

<p><b>Example</b></p>
<pre style="margin-top:0;padding-top:0;">
// $Id: A7-1-3.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $
#include &lt;cstdint&gt;
using IntPtr = std::int32_t*;
using IntConstPtr = std::int32_t* const;
using ConstIntPtr = const std::int32_t*;
void Fn(const std::uint8_t& input) // Compliant
{
    std::int32_t value1 = 10;
    std::int32_t value2 = 20;

    const IntPtr ptr1 =
    &value1; // Non-compliant - deduced type is std::int32_t*
             // const, not const std::int32_t*

    // ptr1 = &value2; // Compilation error, ptr1 is read-only variable

    IntPtr const ptr2 =
    &value1; // Compliant - deduced type is std::int32_t* const

    // ptr2 = &value2; // Compilation error, ptr2 is read-only variable

    IntConstPtr ptr3 = &value1; // Compliant - type is std::int32_t* const, no
                                // additional qualifiers needed

    // ptr3 = &value2; // Compilation error, ptr3 is read-only variable

    ConstIntPtr ptr4 = &value1; // Compliant - type is const std::int32_t*

    const ConstIntPtr ptr5 = &value1; // Non-compliant, type is const
                                      // std::int32_t* const, not const const
                                      // std::int32_t*
    ConstIntPtr const ptr6 =
    &value1; // Compliant - type is const std::int32_t* const
}
</pre>

<p><b>See also</b><br>
â€¢ HIC++ v4.0 [9]: 7.1.4 Place CV-qualifiers on the right hand side of the type they apply to
</p>

'''


def test_language(language):
    return language == 'C++'


def test_entity(file):
    return True


def test_global():
    return False


def check(check, file):

    lexer = None

    for ref in file.filerefs('Typed', 'Type Alias, Typedef'):
        ent = ref.ent()

        # See if the previous lexeme is const or volatile
        if not lexer:
            lexer = file.lexer()
        lexeme = lexer.lexeme(ref.line(), ref.column())
        lexeme = lexeme.previous(ignore_comments=True, ignore_whitespace=True)
        if lexeme and lexeme.text() in {'const', 'volatile'}:
            check.violation(ent, file, ref.line(), ref.column(), ERR1, lexeme.text(), ent.name())
