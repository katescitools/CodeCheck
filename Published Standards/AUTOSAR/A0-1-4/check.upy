
ERR1 = 'Unused parameter'

# The ID for the check


def ids():
    return ('A0-1-4', 'CPP_F027')

# The short name of the check


def name(id):
    return {
        'A0-1-4': 'Published Standards/AUTOSAR/There shall be no unused named parameters in non-virtual functions',
        'CPP_F027': 'All Checks/Language Specific/C and C++/Functions/There shall be no unused named parameters in non-virtual functions',
    }[id]

# The short description of the check


def description():
    return 'There shall be no unused named parameters in non-virtual functions.'

# The long description of the check


def detailed_description():
    return """\
<p><b>Rationale</b></p>
<p>Unused named parameters are often a result of a design changes and can lead to
mismatched parameter lists.</p>
<p>Note: This rule does not apply to unnamed parameters, as they are widely used in
SFINAE and concept compliance.</p>
<p><b>Example</b></p>
<pre style="margin-top:0;padding-top:0;">
//% $Id: A0-1-4.cpp 305588 2018-01-29 11:07:35Z michal.szczepankiewicz $

#include <type_traits>
#include <string>

//Logger.hpp
class Logger
{
public:
struct console_t {};
struct file_t {};

constexpr static console_t console = console_t();
constexpr static file_t file = file_t();

void init(console_t);
void init(file_t, const std::string& prefix);
};

//Logger.cpp
void Logger::init(console_t)
{
//initialization for a console logger
}
void Logger::init(file_t, const std::string& prefix)
{
//initialization for a file logger for a given prefix path
}

//Message.h
struct MessagePolicy {};
struct WriteMessagePolicy final : public MessagePolicy { };

template <typename T> struct is_mutable : std::false_type {};
template <> struct is_mutable<WriteMessagePolicy> : std::true_type {};

template <typename T, typename Policy = MessagePolicy>
class Message
{
public:
static_assert(std::is_base_of<MessagePolicy, Policy>::value == true, "Given parameter is not derived from MessagePolicy");
using value_type = T;

template<typename U = void>
void set(T&& u, typename std::enable_if<is_mutable<Policy>::value, U>::type* = 0)
{
	v = u;
}

private:
value_type v;
};

int main(int, char**)
{
Logger log;
log.init(Logger::console);
log.init(Logger::file, std::string("/tmp/"));

Message<uint8_t> read;
Message<uint8_t, WriteMessagePolicy> write;

//read.set(uint8_t(12)); Compilation error
write.set(uint8_t(12));

return 0;
}
</pre>
<p><b>See also</b></p>
<p>C++ Core Guidelines [11]: F.9: Unused parameters should be unnamed</p>"""

# Tests the type of file


def test_entity(file):
    return file.kind().check('code file')


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def check(check, file):
    use_kind = ["Set", "Use", "Assign", "Return", "Call", "Addr Use", "Modify", "Deref Call", "Deref Modify", "Deref Set", "Deref Use"]

    for ref in sorted(file.filerefs("Define", "Function"), key=lambda ref: ref.line()):
        if "Virtual" not in ref.ent().kindname():
            for ent in ref.ent().ents(refkindstring="", entkindstring="Parameter"):
                if ent.name() != "[unnamed]":
                    kind_refs = [ref.kindname() for ref in ent.refs()]

                    if not any(kind in kind_refs for kind in use_kind):
                        check.violation(ent, file, ent.ref().line(),
                                        ent.ref().column(), ERR1)
