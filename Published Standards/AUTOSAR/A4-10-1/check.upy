import re


ERR1 = 'Only nullptr literal shall be used as the null-pointer-constant'


# The ID for the check
def ids():
    return ('A4-10-1', 'CPP_P040')


# The short name of the check
def name(id):
    return {
        'A4-10-1': 'Published Standards/AUTOSAR/Only nullptr literal shall be used as the null-pointer-constant',
        'CPP_P040': 'All Checks/Language Specific/C and C++/Pointers/Only nullptr literal shall be used as the null-pointer-constant',
    }[id]


# The short description of the check
def description():
    return 'Only nullptr literal shall be used as the null-pointer-constant.'


# The long description of the check
def detailed_description():
    return """
<p><b>Rule</b></p>
<p>Only nullptr literal shall be used as the null-pointer-constant.</p>
<p><b>Rationale</b></p>
<p>In C++, the literal NULL is both the null-pointer-constant and an integer type. To meet
developer expectations, only nullptr pointer literal shall be used as the null-pointer-constant.</p>
<p>Note that, nullptr pointer literal allows parameters forwarding via a template function.</p>
<p><b>Example</b></p>
<pre>
//% $Id: A4-10-1.cpp 298086 2017-11-24 11:13:27Z michal.szczepankiewicz $
#include &lt;cstddef&gt;
#include &lt;cstdint&gt;

void F1(std::int32_t);
void F2(std::int32_t*);
void F3()
{
    F1(0);    // Compliant
    F1(NULL); // Non-compliant - NULL used as an integer,
    // compilable
    // f1(nullptr); // Non-compliant - nullptr used as an integer
    // compilation error
    F2(0);       // Non-compliant - 0 used as the null pointer constant
    F2(NULL);    // Non-compliant - NULL used as the null pointer constant
    F2(nullptr); // Compliant
}
void F4(std::int32_t*);
template &lt;class F, class A&gt;
void F5(F f, A a)
{
    F4(a);
}
void F6()
{
    // f5(f4, NULL); // Non-compliant - function f4(std::int32_t) not declared
    F5(F4, nullptr); // Compliant
}
</pre>
<p><b>See also</b></p>
<p>â€¢ HIC++ v4.0 [9]: 2.5.3 Use nullptr for the null pointer constant</p>
"""


# Tests the type of file
def test_entity(file):
    return file.kind().check('code file, header file')


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def check(check, file):
    for func_ref in file.filerefs("Declare", "Function"):
        func_params = []

        for param_ref in func_ref.ent().refs("", "Parameter"):
            if re.search("int.*\*+", param_ref.ent().type()):
                func_params.append(True)
            else:
                func_params.append(False)

        if any(func_params):
            for call_ref in func_ref.ent().refs("Callby"):
                lexer = call_ref.file().lexer()
                lex = lexer.lexeme(call_ref.line(), call_ref.column())
                in_param = 0
                call_params = []
                param = ""

                if lex.ent() and lex.ent().kind().check("Macro"):
                    continue

                while lex and lex.text() != ";":
                    if lex.text() == "(" and lex.token() == "Punctuation":
                        in_param += 1
                    elif lex.text() == ")" and lex.token() == "Punctuation":
                        in_param -= 1

                        if not in_param:
                            call_params.append(param)
                            break
                    elif in_param and lex.text() != ",":
                        param += lex.text()
                    elif in_param and lex.text() == ",":
                        call_params.append(param)
                        param = ""

                    lex = lex.next(ignore_whitespace=True,
                                   ignore_comments=True)

                for ind, param in enumerate(call_params):
                    pointer_type = False
                    # Normal argument
                    if ind < len(func_params):
                        pointer_type = func_params[ind]
                    # Variadic argument (any type)
                    else:
                        pointer_type = True

                    if pointer_type and param in {"0", "NULL"}:
                        check.violation(call_ref.scope(), call_ref.file(), call_ref.line(), call_ref.column(), ERR1)
