import re

keywords = ["virtual","override","final"]
ERR1 = "Virtual function declaration does not contain exactly one of the three specifiers: (1) virtual, (2) override, (3) final"

# The ID for the check
def ids():
    return ('A10-3-1', 'CPP_D054')

# The short name of the check
def name(id):
    return {
        'A10-3-1': 'Published Standards/AUTOSAR/Virtual function declaration shall contain exactly one of the three specifiers: (1) virtual, (2) override, (3) final',
        'CPP_D054': 'All Checks/Language Specific/C and C++/Declarations and Definitions/Virtual function declaration shall contain exactly one of the three specifiers: (1) virtual, (2) override, (3) final',
    }[id]

# The long description of the check
def detailed_description():
    return """\
<p><b>Rationale</b></p>
<p>Specifying more than one of these three specifiers along with virtual function declaration is redundant and a potential source of errors.</p>
<p>It is recommended to use the virtual specifier only for new virtual function declaration, the override specifier for overrider declaration, and the final specifier for final overrider declaration.</p>
<p>Note that this applies to virtual destructors and virtual operators, too.</p>
<p><b>Example</b></p>
<pre style="margin-top:0;padding-top:0;">
1 // $Id: A10-3-1.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $
2 class A
3 {
4 public:
5 virtual ~A() {} // Compliant
6 virtual void F() noexcept = 0; // Compliant
7 virtual void G() noexcept final = 0; // Non-compliant - virtual final pure
8 // function is redundant
9 virtual void
10 H() noexcept final // Non-compliant - function is virtual and final
11 {
12 }
13 virtual void K() noexcept // Compliant
14 {
15 }
16 virtual void J() noexcept {}
17 virtual void M() noexcept // Compliant
18 {
19 }
20 virtual void Z() noexcept // Compliant
21 {
22 }
23 virtual A& operator+=(A const& rhs) noexcept // Compliant
24 {
25 // ...
26 return *this;
27 }
28 };
29 class B : public A
30 {
31 public:
32 ~B() override {} // Compliant
33 virtual void F() noexcept override // Non-compliant - function is specified
34 // with virtual and override
35 {
36 }
37 void K() noexcept override
38 final // Non-compliant - function is specified with override and final
39 {
40 }
41 virtual void M() noexcept // Compliant - violates A10-3-2
42 {
43 }
44 void Z() noexcept override // Compliant
45 {
46 }
47 void J() noexcept // Non-compliant - virtual function but not marked as
48 // overrider
49 {
50 }
51 A& operator+=(A const& rhs) noexcept override // Compliant - to override
52 // the operator correctly,
53 // its signature needs to be
54 // the same as in the base
55 // class
56 {
57 // ...
58 return *this;
59 }
60 };
</pre>
<p><b>See also</b></p>
<p>C++ Core Guidelines [11]: C.128: Virtual functions should specify exactly one of virtual, override, or final.
</p>"""

# Tests the type of file
def test_entity(file):
    return file.kind().check('header file,code file')

# Optional - Return True if this check should be run on the entire project
# regardless of what files are selected. Should only be used for
# project-level checks
def test_global():
    return False

def test_language(language):
    return language == 'C++'

def check(check, file):
    lexer = file.lexer()
    for ref in file.filerefs("","Virtual Function", True):

        specifier = 0
        lex = lexer.lexeme(ref.line(), ref.column())
        prev = lexer.lexeme(ref.line(), ref.column())

        while prev and prev.text() != "}" and prev.text() != ";" and prev.text() != ":":
            if prev.text() in keywords:
                specifier += 1
            prev = prev.previous(ignore_whitespace=True, ignore_comments=True)

        while lex and lex.text() != "{" and lex.text() != ";":
            if lex.text() in keywords:
                specifier += 1
            lex = lex.next()

        if specifier != 1:
            check.violation(ref.ent(), file, ref.line(), ref.column(), ERR1)

        lex = None
