import re

ERR1 = '#pragma directive shall not be used'

# The ID for the check


def ids():
    return ('A16-7-1', 'CPP_PR030')

# The short name of the check


def name(id):
    return {
        'A16-7-1': """\
Published Standards/AUTOSAR/The #pragma directive shall not be used""",
        'CPP_PR030': """\
All Checks/Language Specific/C and C++/Preprocessor/The #pragma directive shall not be used"""

    }[id]


# The long description of the check
def detailed_description():
    return """
<p><b>Rationale</b></p>
<p>The #pragma directive is implementation-defined and causes the implementation to
behave in implementation-defined manner.</p>
<p><b>Example</b></p>
<pre style="margin-top:0;padding-top:0;">
1 // $Id: A16-7-1.hpp 270497 2017-03-14 14:58:50Z piotr.tanski $
2 // #pragma once // Non-compliant - implementation-defined manner
3 #ifndef A16_7_1_HPP // Compliant - equivalent to #pragma once directive
4 #define A16_7_1_HPP
5
6 // ...
7
8 #endif
</pre>
<p><b>See also</b></p>
<p>â€¢ MISRA C++ 2008 [7]: Rule 16-6-1 All uses of the #pragma directive shall be
documented.</p>
"""

# Tests the type of file


def test_entity(file):
    return file.kind().check('header file')


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def check(check, file):
    if not re.search("#pragma", file.contents()):
        return

    lexer = file.lexer()

    if not lexer:
        return

    for lex in lexer.lexemes():
        if lex.text() == "pragma" and lex.token() == "Preprocessor":
            check.violation(lex.ent(), file, lex.line_begin(),
                            lex.column_begin(), ERR1)
