# This script is designed to run with Understand - CodeCheck
# Written by Jordan Colbeth
# 10-12-2021

import re

OPT1 = "Case/Default clauses with return"
OPT1RETURN = "Return allowed"
OPT1NORETURN = "Return not allowed"

ERR1 = 'Unconditional throw or break statement does not terminate non-empty switch-clause'

# The ID for the check
def ids():
    return ('M6-4-5', 'CPP_C033', 'MISRA04_15.2', 'MISRA08_6-4-5', 'MISRA12_16.3')

# The short name of the check
def name(id):
    return {
        'M6-4-5': 'Published Standards/AUTOSAR/An unconditional throw or break statement shall terminate every non-empty switch-clause',
        'CPP_C033': 'All Checks/Language Specific/C and C++/Control Flow/An unconditional throw or break statement shall terminate every non-empty switch-clause',
        'MISRA04_15.2': 'Published Standards/MISRA-C 2004/15.2 An unconditional break statement shall terminate every non-empty switch clause',
        'MISRA08_6-4-5': 'Published Standards/MISRA-C++ 2008/6-4-5 An unconditional throw or break statement shall terminate every non-empty switch-clause',
        'MISRA12_16.3': 'Published Standards/MISRA C 2012/16.3 An unconditional break statement shall terminate every switch-clause',
    }[id]

# The short description of the check
def description():
    return '( Required ) An unconditional throw or break statement shall terminate every non-empty switch-clause.'


def report_info(id):
    return {
        'M6-4-5': {
            'Automation': 'Automated',
            'Category':   'Required',
        },
        'MISRA04_15.2': {
            'Category': 'Required',
        },
        'MISRA08_6-4-5': {
            'Category': 'Required',
        },
        'MISRA12_16.3': {
            'Category': 'Required',
        },
    }[id]


# The long description of the check
def detailed_description(id):
    return {
    	'M6-4-5' : """\
<p><b>Developer's Note:</b><br>
This check is reliant upon Understand's Control Flow graph. If errors exist in the project analysis, the Control Flow graph
may not render correctly. If this is the case, then this check may throw false positives. This check will not detect code
that exists after a break, throw or return statement as it is normally unreachable. Unreachable code is detected by another check.
</p>

<p>
<b>Rationale</b><br>
If a developer fails to add a <i>break</i> statement to the end of a <i>switch-clause</i>, then control flow falls
into any following <i>switch-clause</i>. Whilst this is sometimes intentional, it is often an error.
</p>

<p>
To ensure that such errors can be detected, the last statement in every <i>switch-clause</i> shall be a
<i>break</i> statement, or if the <i>switch-clause</i> is a compound statement, then the last statement in the
compound statement shall be a break statement.
</p>

<p>
A special case exists if the <i>switch-clause</i> is empty, as this allows groups of clauses requiring
identical statements to be created.
</p>

<br>
<b>Example</b><pre style="margin-top:0;padding-top:0;">
  switch ( x )
  {
    case 0:
      break; // Compliant
    case 1:  // Compliant - empty drop through
    case 2:  // allows a group
      break; // Compliant
    case 3:
      throw; // Compliant
    case 4:
      a = b;
             // Non-compliant - non empty drop through
    default:
      ;      // Non-compliant - default must also have "break"
  }
</pre>""",
        'CPP_C033': """\
<p><b>Developer's Note:</b><br>
This check is reliant upon Understand's Control Flow graph. If errors exist in the project analysis, the Control Flow graph
may not render correctly. If this is the case, then this check may throw false positives. This check will not detect code
that exists after a break, throw or return statement as it is normally unreachable. Unreachable code is detected by another check.
</p>

<p>
<b>Rationale</b><br>
If a developer fails to add a <i>break</i> statement to the end of a <i>switch-clause</i>, then control flow falls
into any following <i>switch-clause</i>. Whilst this is sometimes intentional, it is often an error.
</p>

<p>
To ensure that such errors can be detected, the last statement in every <i>switch-clause</i> shall be a
<i>break</i> statement, or if the <i>switch-clause</i> is a compound statement, then the last statement in the
compound statement shall be a break statement.
</p>

<p>
A special case exists if the <i>switch-clause</i> is empty, as this allows groups of clauses requiring
identical statements to be created.
</p>

<br>
<b>Example</b>
<pre style="margin-top:0;padding-top:0;">
  switch ( x )
  {
    case 0:
      break; // Compliant
    case 1:  // Compliant - empty drop through
    case 2:  // allows a group
      break; // Compliant
    case 3:
      throw; // Compliant
    case 4:
      a = b;
             // Non-compliant - non empty drop through
    default:
      ;      // Non-compliant - default must also have "break"
  }
</pre>""",
    'MISRA04_15.2' : """\
<p><b>Developer's Note:</b><br>
This check is reliant upon Understand's Control Flow graph. If errors exist in the project analysis, the Control Flow graph
may not render correctly. If this is the case, then this check may throw false positives. This check will not detect code
that exists after a break, throw or return statement as it is normally unreachable. Unreachable code is detected by another check.
</p>

<p><b>Rationale</b><br>
The last statement in every switch clause shall be a <i>break</i> statement, or if the <i>switch</i> clause
is a compound statement, then the last statement in the compound statement shall be a <i>break</i>
statement.</p>
<br>
<b>Example</b><pre style="margin-top:0;padding-top:0;">
  switch ( x )
  {
    case 0:
      break; // Compliant
    case 1:  // Compliant - empty drop through
    case 2:  // allows a group
      break; // Compliant
    case 3:
      a = b;
             // Non-compliant - non empty drop through
    default:
      ;      // Non-compliant - default must also have "break"
  }
</pre>""",
    'MISRA08_6-4-5' : """\
<p><b>Developer's Note:</b><br>
This check is reliant upon Understand's Control Flow graph. If errors exist in the project analysis, the Control Flow graph
may not render correctly. If this is the case, then this check may throw false positives. This check will not detect code
that exists after a break, throw or return statement as it is normally unreachable. Unreachable code is detected by another check.
</p>

<p>
<b>Rationale</b><br>
If a developer fails to add a <i>break</i> statement to the end of a <i>switch-clause</i>, then control flow falls
into any following <i>switch-clause</i>. Whilst this is sometimes intentional, it is often an error.
</p>

<p>
To ensure that such errors can be detected, the last statement in every <i>switch-clause</i> shall be a
<i>break</i> statement, or if the <i>switch-clause</i> is a compound statement, then the last statement in the
compound statement shall be a break statement.
</p>

<p>
A special case exists if the <i>switch-clause</i> is empty, as this allows groups of clauses requiring
identical statements to be created.
</p>

<br>
<b>Example</b><pre style="margin-top:0;padding-top:0;">
  switch ( x )
  {
    case 0:
      break; // Compliant
    case 1:  // Compliant - empty drop through
    case 2:  // allows a group
      break; // Compliant
    case 3:
      throw; // Compliant
    case 4:
      a = b;
             // Non-compliant - non empty drop through
    default:
      ;      // Non-compliant - default must also have "break"
  }
</pre>""",
    'MISRA12_16.3' : """\
<p><b>Developer's Note:</b><br>
This check is reliant upon Understand's Control Flow graph. If errors exist in the project analysis, the Control Flow graph
may not render correctly. If this is the case, then this check may throw false positives. This check will not detect code
that exists after a break, throw or return statement as it is normally unreachable. Unreachable code is detected by another check.
</p>

<p>
<b>Rationale</b><br>
If a developer fails to end a <i>switch-clause</i> with a <i>break</i> statement, then control flow “falls” into the
following <i>switch-clause</i> or, if there is no such clause, off the end and into the statement following
the <i>switch</i> statement. Whilst falling into a following <i>switch-clause</i> is sometimes intentional, it is often
an error. An unterminated <i>switch-clause</i> occurring at the end of a <i>switch</i> statement may fall into any
<i>switch-clauses</i> which are added later.
</p>

<p>
To ensure that such errors can be detected, the last statement in every <i>switch-clause</i> shall be a
<i>break</i> statement, or if the <i>switch-clause</i> is a compound statement, then the last statement in the
compound statement shall be a break statement.
</p>

<p>
Note: a <i>switch-clause</i> is defined as containing at least one statement. Two consecutive labels, <i>case</i> or
<i>default</i>, do not have any intervening statement and are therefore permitted by this rule.
</p>

<br>
<b>Example</b><pre style="margin-top:0;padding-top:0;">
switch ( x )
{
  case 0:
    break; /* Compliant - unconditional break */
  case 1: /* Compliant - empty fall through allows a group */
  case 2:
    break; /* Compliant */
  case 4:
    a = b; /* Non-compliant - break omitted */
  case 5:
    if ( a == b )
    {
      ++a;
      break; /* Non-compliant - conditional break */
    }
  default:
    ; /* Non-compliant - default must also have a break */
}
</pre>""",
    }[id]

def test_entity(file):
    return file.kind().check('code file, header file')

def test_language(language):
    return language == 'C++'

# Define configurable options for the check
def define_options(check):
    check.option().choice('returnAllowed',OPT1,[OPT1RETURN,OPT1NORETURN],OPT1NORETURN);


# This is the actual test being performed on the user's code
def check(check, file):

    funcRefs = file.filerefs("Define", "Function")
    if not funcRefs:
        return

    # Loop through all functions
    for funcRef in funcRefs:
        func = funcRef.ent()
        # Spin up control flow graph
        if not func.control_flow_graph():
            continue
        cfg = func.control_flow_graph()

        start = cfg.start()
        end = start.end_node()
        nodes = cfg.nodes()

        # Test all nodes for switch cases and switch default statements
        for node in nodes:
            kind = node.kind()
            if (kind == "switch-case" or kind == "switch-default"):
                for child in node.children():
                    line = node.line_begin()
                    column = node.column_begin()
                    visited = {}
                    # Run the testing function on this switch node
                    testCase(check, funcRef, file, line, column, node, child, visited)


# This function walks the switch case statements to ensure they end in a break or throw command
def testCase(check, funcRef, file, line, column, node, child, visited):
    parent = node
    node = child
    kind = node.kind()
    canReturn = (check.option().lookup("returnAllowed") == OPT1RETURN)

    if kind == "break":
        return
    if kind == "throw":
        return
    if (canReturn == True and kind == "return"):
        return

    if (kind == ("switch-case" or "switch-default" or "end-switch")):
        check.violation(funcRef.ent(), file, line, column, ERR1)
        return

    # Flag this node as being visited, prevents circular references from crashing Understand
    if node in visited:
        return
    else:
        visited[node] = 1

    children = node.children()
    if children:
        for child in children:

            # Special case for return statements. Return statements have children until the end of the function which throws off the line and column tracking
            # if not parent.kind() == "return":
            #     if parent.line_begin() != 0:
            #         line = parent.line_begin()
            #     if parent.column_begin() != 0:
            #         column = parent.column_begin()

            return testCase(check, funcRef, file, line, column, node, child, visited)

    else:
        check.violation(funcRef.ent(), file, line, column, ERR1)
        return
 
