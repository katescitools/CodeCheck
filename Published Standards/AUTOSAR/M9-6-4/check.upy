ERR1 = 'Bit-field should have a length of more than one bit'


# The ID for the check
def ids():
    return ('M9-6-4', 'CPP_B006')

# The short name of the check
def name(id):
    return {
        'M9-6-4': """\
Published Standards/AUTOSAR/Bit-field Length""",
        'CPP_B006': """\
All Checks/Language Specific/C and C++/Bit-fields/Bit-field Length"""

    }[id]


# The long description of the check
def detailed_description():
    return """
<p><b>Rule</b></p>
<p>Named bit-fields with signed integer type shall have a
length of more than one bit.</p>
<p><b>Rationale</b></p>
<p>The values which may be represented by a bit-field of length one may not meet developer
expectations. Anonymous signed bit-fields of any length are allowed.</p>
<p><b>Example</b></p>
<pre style="margin-top:0;padding-top:0;">
struct S
{
 signed int a : 1; // Non-compliant
 signed int : 1; // Compliant
 signed int : 0; // Compliant
 signed int b : 2; // Compliant
 signed int : 2; // Compliant
};
</pre>
"""


# Tests the type of file
def test_entity(file):
    return file.kind().check('code file, header file')


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def check(check, file):
    lexer = file.lexer()

    if not lexer:
        return

    for obj_ref in file.filerefs("Define", "Object"):
        lex = lexer.lexeme(obj_ref.line(), obj_ref.column())
        lex = lex.previous(ignore_whitespace=True)
        prev_lex = lex.previous(ignore_whitespace=True)
        bitfield = obj_ref.ent().freetext("Bitfield")

        if (bitfield
            and (obj_ref.ent().name() != "[unnamed]" and (bitfield.isdigit() and int(bitfield) <= 1))
            and (prev_lex.text() == "signed" and prev_lex.token() == "Keyword")
            and (lex.text() == "int" and lex.token() == "Keyword")
            ):
            check.violation(obj_ref.ent(), file, obj_ref.line(),
                            obj_ref.column(), ERR1)
