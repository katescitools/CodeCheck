ERR1 = 'Uninitialized memory is read'
FUNDAMENTAL_TYPES = {"short", "int", "signed", "long",
                     "unsigned", "bool", "char", "float", "double"}


# The ID for the check
def ids():
    return ('A8-5-0', 'CPP_M005')

def name(id):
    return {
        'A8-5-0': """\
Published Standards/AUTOSAR/Uninitialized Memory Read""",
        'CPP_M005': """\
All Checks/Language Specific/C and C++/Memory Allocation/Uninitialized Memory
Read"""

    }[id]

# The long description of the check
def detailed_description():
    return """
<p><b>Rule</b></p>
<p>All memory shall be initialized before it is read.</p>
<p><b>Rationale</b></p>
<p>Objects with automatic or dynamic storage duration are default-initialized if no initializer
is specified. Default initialization produces indeterminate values for objects of neither
class nor array types. Default initialization of array types leads to default initialization
of each array element. Reading from indeterminate values may produce undefined
behavior.</p>
<p>Thus, all local variables, member variables, or objects allocated dynamically must
be explicitly initialized before their values are read, unless they are of class type or
array of non-fundamental type. It is recommended practice to initialize all such objects
immediately when they are defined.</p>
<p><b>Notes</b></p>
<p>Zero-initialization will happen before any other initialization for any objects with
static or thread-local storage duration. Thus, such objects need not be explicitly
initialized.</p>
<p>Members of classes and structs are not included in this checking due to their broad scope of usage.</p>
<p><b>Example</b></p>
<pre style="margin-top:0;padding-top:0;">
1 // $Id: A8-5-0.cpp 307536 2018-02-14 12:35:11Z jan.babst $
2 #include &lt;cstdint&gt;
3 #include &lt;string&gt;
4
5 static std::int32_t zero; // Compliant - Variable with static storage duration
6 // is zero-initialized.
7
8 void local()
9 {
10 std::int32_t a; // No initialization
11 std::int32_t b{}; // Compliant - zero initialization
12
13 b = a; // Non-compliant - uninitialized memory read
14 a = zero; // Compliant - a is zero now
15 b = a; // Compliant - read from initialized memory
16
17 std::string s; // Compliant - default constructor is a called
18 // read from s
19 }
20
21 void dynamic()
22 {
23 // Note: These examples violate A18-5-2
24
25 auto const a = new std::int32_t; // No initialization
26 auto const b = new std::int32_t{}; // Compliant - zero initialization
27
28 *b = *a; // Non-compliant - uninitialized memory read
29 *a = zero; // Compliant - a is zero now
30 *b = *a; // Compliant - read from initialized memory
31
32 delete b;
33 delete a;
34
35 auto const s =
36 new std::string; // Compliant - default constructor is a called
37 // read from *s
38 delete s;
39 }
40
41 // Members of Bad are default-initialized by the (implicitly generated) default
42 // constructor. Note that this violates A12-1-1.
43 struct Bad
44 {
45 std::int32_t a;
46 std::int32_t b;
47 };
48
49 // Compliant - Members of Good are explicitly initialized.
50 // This also complies to A12-1-1.
51 struct Good
52 {
53 std::int32_t a{0};
54 std::int32_t b{0};
55 };
56
57 void members()
58 {
59 Bad bad; // Default constructor is called, but members a not initialized
60
61 bad.b = bad.a; // Non-compliant - uninitialized memory read
62 bad.a = zero; // Compliant - bad.a is zero now
63 bad.b = bad.a; // Compliant - read from initialized memory
64
65 Good good; // Default constructor is called and initializes members
66
67 std::int32_t x = good.a; // Compliant
68 std::int32_t y = good.b; // Compliant
69 }
</pre>
<p><b>See also</b></p>
<p>• MISRA C++ 2008 [7]: 8-5-1: All variables shall have a defined value before they
are used.</p>
<p>• HIC++ v4.0 [9]: 8.4.1: Do not access an invalid object or an object with
indeterminate value</p>
<p>• JSF December 2005 [8]: AV Rule 142: All variables shall be initialized before
use.</p>
<p>• SEI CERT C++ Coding Standard [10]: EXP53-CPP: Do not read uninitialized
memory</p>
<p>• C++ Core Guidelines [11]: ES.20: Always initialize an object</p>
<p>• ISO/IEC 14882:2014 [3]: 8.5: [dcl.init]</p>
"""


# Tests the type of file
def test_entity(file):
    return file.kind().check('code file, header file')


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def check(check, file):
    for func_ref in file.filerefs("Define", "Function"):
        for obj_ref in func_ref.ent().refs("Define", "Object ~Static"):
            ent, ent_type = get_ent_type(obj_ref.ent())

            if ent_type and any(_type in ent_type for _type in FUNDAMENTAL_TYPES) and ent.kindname() not in {"Struct", "Class"}:
                is_init = is_initialized(obj_ref)
                assign_ptr = []

                for _ref in obj_ref.ent().refs("Assignby Ptr"):
                    assign_ptr.append(_ref.line())

                first_use, first_set = get_used_set(
                    obj_ref, is_init, assign_ptr)

                if not is_init and first_use and first_set and first_use.line() < first_set.line():
                    check.violation(obj_ref.ent(), file, first_use.line(),
                                    first_use.column(), ERR1)


def get_used_set(obj_ref, is_init, assign_ptr, func_ref=None):
    first_use, first_set = None, None

    for _ref in sorted(obj_ref.ent().refs("Useby ~Inactive, Setby"), key=lambda x: x.line()):
        if func_ref and func_ref.ent().id() != _ref.ent().id():
            continue

        if not first_use and _ref.kind().check("Useby") and _ref.line() in assign_ptr:
            first_set = _ref
        elif not first_set and _ref.kind().check("Setby"):
            if _ref.kind().check("Init") and not is_init:
                continue
            first_set = _ref
        elif not first_use and _ref.kind().check("Useby"):
            first_use = _ref
        elif first_use and first_set:
            break

    return first_use, first_set


def is_initialized(_ref):
    init_value = _ref.ent().freetext("InitValue")

    if "string" in _ref.ent().type():
        return True
    elif init_value and "new" in init_value and "{" not in init_value and "}" not in init_value:
        lexer = _ref.file().lexer()
        lex = lexer.lexeme(_ref.line(), _ref.column())
        new_keyword = False

        while lex and lex.text() != ";":
            if lex.text() == "new" and lex.token() == "Keyword":
                new_keyword = True

            lex = lex.next(ignore_whitespace=True, ignore_comments=True)

        if not new_keyword:
            return True
    elif init_value:
        return True
    else:
        lexer = _ref.file().lexer()
        lex = lexer.lexeme(_ref.line(), _ref.column())
        lex = lex.next(ignore_whitespace=True, ignore_comments=True)

        if lex.text() in {"=", "{"} and lex.token() in {"Operator", "Punctuation"}:
            return True

    return False


def get_ent_type(entity):
    typed_ref = entity.ref("Typed")

    if not typed_ref:
        return entity, entity.type()

    while typed_ref:
        obj_ent = typed_ref.ent()
        obj_ref_type = obj_ent.type()
        typed_ref = typed_ref.ent().ref("Typed")

    return obj_ent, obj_ref_type
