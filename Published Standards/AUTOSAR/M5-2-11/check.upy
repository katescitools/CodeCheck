# This script is designed to run with Understand - CodeCheck
# Written by Robby Bennett
# 9-17-21

import re

ERR1 = ', operator overloaded'
ERR2 = '&& operator overloaded'
ERR3 = '|| operator overloaded'

def ids():
    return ('M5-2-11', 'MISRA08_5-2-11', 'CPP_D019')

def name(id):
    return {
        'M5-2-11': 'Published Standards/AUTOSAR/The comma operator, && operator and the || operator shall not be overloaded',
        'MISRA08_5-2-11': 'Published Standards/MISRA-C++ 2008/5-2-11 The comma operator, && operator and the || operator shall not be overloaded',
        'CPP_D019': 'All Checks/Language Specific/C and C++/Declarations and Definitions/The comma operator, && operator and the || operator shall not be overloaded',
    }[id]

def detailed_description():
    return '''\
<p><b>Rationale</b></p>
<p>Overloaded versions of the comma and logical conjunction operators have the semantics of
function calls whose sequence point and ordering semantics are different from those of the builtin versions. It may not be clear at the point of use that these operators are overloaded, and so
developers may be unaware which semantics apply.</p>
<p><b>Example</b></p>
<pre style="margin-top:0;padding-top:0;">
#include "util.h"
class A
{
public:
    UtilType getValue ( );
    UtilType setValue ( UtilType const & );
};
void f1 ( A & a1, A & a2 )
{
    a1.getValue ( ) && a2.setValue ( 0 ); // Short circuiting may occur
}
bool operator && ( UtilType const &, UtilType const & ); // Non-compliant
void f2 ( A & a1, A & a2 )
{
    a1.getValue ( ) && a2.setValue ( 0 ); // Both operands evaluated
}
</pre>
<p>If the type returned by getValue and setValue has an overloaded operator &&, then both getValue
and setValue will be evaluated.</p>
<p><b>See also</b></p>
<p>ISO/IEC 14882:2003 [1] ยง5.14, ยง5.15, ยง5.18</p>'''

def test_entity(file):
    return file.kind().check('header file, code file')

def test_global():
    return False

def test_language(language):
    return language == 'C++'

def check(check, file):
    for ref in file.filerefs('Declare', ''):
        ent = ref.ent()
        name = ent.name()
        if name == 'operator,':
            check.violation(ent, file, ref.line(), ref.column(), ERR1)
        elif name == 'operator&&':
            check.violation(ent, file, ref.line(), ref.column(), ERR2)
        elif name == 'operator||':
            check.violation(ent, file, ref.line(), ref.column(), ERR3)
