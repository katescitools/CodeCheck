import re

CHECK_DESC = 'The std::move shall not be used on objects declared const or const&'

# The ID for the check
def ids():
    return ('A18-9-3', 'CPP_L023')

# The short name of the check
def name(id):
    return {
        'A18-9-3': '''\
Published Standards/AUTOSAR/''' + CHECK_DESC,
        'CPP_L023': '''\
All Checks/Language Specific/C and C++/Libraries/''' + CHECK_DESC

    }[id]


# The long description of the check
def detailed_description():
    return '''\
<p><b>Rationale</b></p>
<p>If an object is declared const or const&, then it will actually never be moved using the std::move.</p>
<p><b>Example</b></p>
<pre>
// $Id: A18-9-3.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $
#include &lt;utility&gt;
class A
{
    // Implementation
};
void F1()
{
    const A a1{};
    A a2 = a1;            // Compliant - copy constructor is called
    A a3 = std::move(a1); // Non-compliant - copy constructor is called
                          // implicitly instead of move constructor
}
</pre>
<p><b>See also</b></p>
<p>HIC++ v4.0 [9]: 17.3.1 Do not use std::move on objects declared with const or const& type.
</p>'''

# Tests the type of file
def test_entity(file):
    return file.kind().check('header file,code file')

# Optional - Return True if this check should be run on the entire project
# regardless of what files are selected. Should only be used for
# project-level checks
def test_global():
    return False

def test_language(language):
    return language == 'C++'

def is_move(lex, end_line):
    move = False
    flag = False
    while lex and lex.line_begin() == end_line:
        if lex.previous(ignore_whitespace=True, ignore_comments=True).text() == '(':
            flag = True
        if flag and lex.previous(ignore_whitespace=True, ignore_comments=True).text() == 'move':
            move = True
        lex = lex.previous(ignore_whitespace=True, ignore_comments=True)
    return move

def check(check, file):
    for ref in file.filerefs('Define', 'Object', True):
        ent = ref.ent()

        # Skip if no not a const object
        if not ent.type() or not re.search('const', ent.type()):
            continue

        for inner in ref.ent().refs('Useby'):
            inner_ent = inner.ent()

            # Skip unless resolved
            if inner_ent.kind().check('Unresolved'):
                continue

            # Skip unless the preceded by "move("
            lex = inner_ent.lexer(False, 8, True, False)
            if not is_move(lex.lexeme(inner.line(), inner.column()), inner.line()):
                continue

            check.violation(None, file, inner.line(), inner.column(), CHECK_DESC)
