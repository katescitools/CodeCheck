# This script is designed to run with Understand - CodeCheck
# Written by Robby Bennett
# 9-17-21


import re


ERR1 = 'reinterpret_cast is used'


def ids():
    return ('A5-2-4', 'CPP_E041')


def name(id):
    return {
        'A5-2-4': 'Published Standards/AUTOSAR/reinterpret_cast shall not be used',
        'CPP_E041': 'All Checks/Language Specific/C and C++/Expressions/reinterpret_cast shall not be used',
    }[id]


def detailed_description():
    return '''\
<p><b>Rationale</b></p>

<p>
Use of reinterpret_cast may violate type safety and cause the program to access a
variable as if it were of another, unrelated type.
</p>

<p><b>Example</b></p>

<pre style="margin-top:0;padding-top:0;">
// $Id: A5-2-4.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $
#include <cstdint>
#include <string>
void F1() noexcept
{
    std::string str = "Hello";
    std::int32_t* ptr = reinterpret_cast<std::int32_t*>(&str);  // Non-compliant
}
struct A
{
    std::int32_t x;
    std::int32_t y;
};
class B
{
  public:
    virtual ~B() {}

  private:
    std::int32_t x;
};
class C : public B
{
};
class D : public B
{
};
void F2(A* ptr) noexcept
{
    B* b1 = reinterpret_cast<B*>(ptr);  // Non-compliant
    std::int32_t num = 0;
    A* a1 = reinterpret_cast<A*>(num);  // Non-compliant
    A* a2 = (A*)
        num;  // Compliant with this rule, but non-compliant with Rule A5-2-2.
    B* b2 = reinterpret_cast<B*>(num);  // Non-compliant
    D d;
    C* c1 = reinterpret_cast<C*>(&d);  // Non-compliant - cross cast
    C* c2 = (C*)&d;  // Compliant with this rule, but non-compliant with Rule
                     // A5-2-2. Cross-cast.
    B* b3 = &d;      // Compliant - class D is a subclass of class B
}
</pre>'''


def test_entity(file):
    return file.kind().check('header file, code file')


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def check(check, file):
    pattern = re.compile('reinterpret_cast')

    if not pattern.search(file.contents()):
        return

    for lexeme in file.lexer().lexemes():
        token = lexeme.token()
        if token not in {'Whitespace', 'Comment', 'Newline'}:
            if lexeme.text() == 'reinterpret_cast':
                check.violation(lexeme.ent(), file, lexeme.line_begin(), lexeme.column_begin(), ERR1)
