ERR1 = 'Relational operator does not return a boolean value'
RELATIONAL_OPERATORS = {"operator==", "operator!=",
                        "operator<", "operator<=", "operator>", "operator>="}


# The ID for the check
def ids():
    return ('A13-2-3', 'CPP_T042')


# The short name of the check
def name(id):
    return {
        'A13-2-3': 'Published Standards/AUTOSAR/A relational operator shall return a boolean value',
        'CPP_T042': 'All Checks/Language Specific/C and C++/Types/A relational operator shall return a boolean value',
    }[id]


# The long description of the check
def detailed_description():
    return """
<p><b>Rationale</b></p>
<p>Returning a type “bool” from a relational operator is consistent with the C++ Standard
Library.</p>
<p><b>Example</b></p>
<pre style="margin-top:0;padding-top:0;">
1 // $Id: A13-2-3.cpp 271687 2017-03-23 08:57:35Z piotr.tanski $
2 #include <cstdint>
3
4 class A
5 {
6 };
7
8 bool operator==(A const&, A const&) noexcept // Compliant
9 {
10 return true;
11 }
12 bool operator<(A const&, A const&) noexcept // Compliant
13 {
14 return false;
15 }
16 bool operator!=(A const& lhs, A const& rhs) noexcept // Compliant
17 {
18 return !(operator==(lhs, rhs));
19 }
20 std::int32_t operator>(A const&, A const&) noexcept // Non-compliant
21 {
22 return -1;
23 }
24 A operator>=(A const&, A const&) noexcept // Non-compliant
25 {
26 return A{};
27 }
28 const A& operator<=(A const& lhs, A const& rhs) noexcept // Non-compliant
29 {
30 return lhs;
31 }
</pre>
<p><b>See also</b></p>
<p>• HIC++ v4.0 [9]: 13.2.2 Ensure that the return type of an overloaded binary
operator matches the built-in counterparts.</p>
"""


# Tests the type of file
def test_entity(file):
    return file.kind().check('code file')


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def check(check, file):
    for ref in file.filerefs("Define", "Function"):
        ref_ent = ref.ent()
        if ref_ent.name() in RELATIONAL_OPERATORS and ref_ent.type() != "bool":
            typed_ref = ref_ent.ref("Typed")
            typed_ent = ref_ent
            while typed_ref:
                typed_ref = typed_ref.ent().ref("Typed")
                if typed_ref:
                    typed_ent = typed_ref.ent()
            if typed_ent.type() == "bool":
                continue

            check.violation(ref_ent, file, ref.line(), ref.column(), ERR1)
