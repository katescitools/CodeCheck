import re

ERR1 = "Each overriding virtual function shall be declared with the override or final specifier"

# The ID for the check
def ids():
    return ('A10-3-2', 'CPP_F036')

# The short name of the check
def name(id):
    return {
        'A10-3-2': 'Published Standards/AUTOSAR/Each overriding virtual function shall be declared with the override or final specifier',
        'CPP_F036': 'All Checks/Language Specific/C and C++/Functions/Each overriding virtual function shall be declared with the override or final specifier',
    }[id]

# The long description of the check
def detailed_description():
    return """\
<p><b>Rationale</b></p>
<p>Explicit use of the override or final specifier enables the compiler to catch mismatch of types and names between base and derived classes virtual functions.</p>
<p>Note that this rule applies to virtual destructor overriders, too.</p>
<p>Also, note that this rule applies to a pure virtual function which overrides another pure virtual function.</p>
<p><b>Example</b></p>
<pre style="margin-top:0;padding-top:0;">
1 // $Id: A10-3-2.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $
2 class A
3 {
4 public:
5 virtual ~A() {}
6 virtual void F() noexcept = 0;
7 virtual void G() noexcept {}
8 virtual void Z() noexcept {}
9 virtual A& operator+=(A const& oth) = 0;
10 };
11 class B : public A
12 {
13 public:
14 ~B() override {} // Compliant
15 void F() noexcept // Non-compliant
16 {
17 }
18 virtual void G() noexcept // Non-compliant
19 {
20 }
21 void Z() noexcept override // Compliant
22 {
23 }
24 B& operator+=(A const& oth) override // Compliant
25 {
26 return *this;
27 }
28 };
29 class C : public A
30 {
31 public:
32 ~C() {} // Non-compliant
33 void F() noexcept override // Compliant
34 {
35 }
36 void G() noexcept override // Compliant
37 {
38 }
39 void Z() noexcept override // Compliant
40 {
41 }
42 C& operator+=(A const& oth) // Non-compliant
43 {
44 return *this;
45 }
46 };
</pre>
<p><b>See also</b></p>
<p>HIC++ v4.0 [9]: 10.2.1 Use the override special identifier when overriding a virtual function
</p>
<p>C++ Core Guidelines [11]: C.128: Virtual functions should specify exactly one of virtual, override, or final.
</p>"""

# Tests the type of file
def test_entity(file):
    return file.kind().check('header file,code file')

# Optional - Return True if this check should be run on the entire project
# regardless of what files are selected. Should only be used for
# project-level checks
def test_global():
    return False

def test_language(language):
    return language == 'C++'

def check(check, file):
	for ref in file.filerefs("Overriddenby"," Virtual Function", True):
		if not (re.search("override", ref.ent().contents().split('{')[0]) or re.search("final", ref.ent().contents().split('{')[0])):
			check.violation(ref.ent(), file, ref.line(), ref.column(), ERR1)
