# This script is designed to run with Understand - CodeCheck
# Converted to python by Jason Quinn
# 01-25-23

import re
import Modules

ERR1 = """\
Non-unique typedef identifier conflicts with file %1 at %2:%3\
"""

DEF_NAME = """\
17.7 The value returned by a function having non-void return type shall be used"""

# The ID for the check
def ids():
    return ('MISRA12_17.7', 'A0-1-2', 'CPP_F024', 'MISRA08_0-1-7')

# Required - Return the short name of the check
def name(id):
    return {
            'MISRA12_17.7': "Published Standards/MISRA C 2012/" + DEF_NAME,
            'MISRA08_0-1-7': """\
Published Standards/MISRA-C++ 2008/0-1-7 The value returned by a function having
a non-void return type that is not an overloaded operator shall always be used
            """,
            'A0-1-2': 'Published Standards/AUTOSAR/The value returned by a function shall be used',
            'CPP_F024': 'All Checks/Language Specific/C and C++/Functions/The value returned by a function shall be used',

            }[id]


    # The description of the check
def detailed_description(id):
    return {
        'MISRA12_17.7': """\
<p><b>Rationale</b></p>
<p>It is possible to call a function without using the return value, which may
be an error. If the return value of a function is intended not to be used
explicitly, it should be cast to the void type. This has the effect of using the
value without violating Rule 2.2.</p>

<p><b>Example</b></p>

<pre style="margin-top:0;padding-top:0;">

  uint16_t func ( uin t16_t para1 )
  {
    return para1;
  }

  uint16_t x;
  void discarded ( uint16_t para2 )
  {
    func ( para2 ); /* Non-compliant - value discarded */
    ( void ) func ( para2 ); /* Compliant */
    x = func ( para2 ); /* Compliant */
  }

</pre>

<p><b>See also</b></p>
<p>Dir 4.7, Rule 2.2</p>
""",
        'MISRA08-0-1-7': """\

<p><b>Rationale</b></p>
<p>In C++ it is possible to call a function without using the return value,
which may be an error. The return value of a function shall always be used.
Overloaded operators are excluded, as they should behave in the same way as
built-in operators.</p>
<p><b>Exception</b></p>
<p>The return value of a function may be discarded by use of a (void) cast.
</p>
<b>Example</b><pre style="margin-top:0;padding-top:0;">
  uint16_t func ( uint16_t para1 ) 
  { 
     return para1; 
  }
  void discarded ( uint16_t para2 ) 
  { 
     func ( para2 );         // value discarded Â– Non-compliant 
     (void)func ( para2 );   // Compliant 
  }</pre>""",
        'A0-1-2': """\
<p>The value returned by a function having a non-void return type that is not an
overloaded operator shall be used.</p>
<p><b>Rationale</b></p>
<p>A called function may provide essential information about its process status
and result through return statement. Calling a function without using the return
value should be a warning that incorrect assumptions about the process were
made.</p>
<p>Overloaded operators are excluded, as they should behave in the same way as built-in
operators.</p>
<p><b>Exception</b></p>
<p>The return value of a function call may be discarded by use of a
static_cast<void> cast, so intentions of a programmer are explicitly stated.</p>
<p><b>Example</b></p>
<pre>
// $Id: A0-1-2.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $
#include &lt;algorithm&gt;
#include &lt;cstdint&gt;
#include &lt;vector&gt;
std::uint8_t Fn1() noexcept
{
  return 0U;
}
void Fn2() noexcept
{
  std::uint8_t x = Fn1(); // Compliant
  Fn1(); // Non-compliant
  static_cast&lt;void&gt;(Fn1()); // Compliant by exception
}
void Fn3()
{
  std::vector&lt;std::int8_t&gt; v{0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5};
  std::unique(v.begin(), v.end()); // Non-compliant
  v.erase(std::unique(v.begin(), v.end()), v.end()); // Compliant
}
</pre>""",
        'CPP_F024': """\
<p>The value returned by a function having a non-void return type that is not an
overloaded operator shall be used.</p>
<p><b>Rationale</b></p>
<p>A called function may provide essential information about its process status
and result through return statement. Calling a function without using the return
value should be a warning that incorrect assumptions about the process were
made.</p>
<p>Overloaded operators are excluded, as they should behave in the same way as built-in
operators.</p>
<p><b>Exception</b></p>
<p>The return value of a function call may be discarded by use of a
static_cast<void> cast, so intentions of a programmer are explicitly stated.</p>
<p><b>Example</b></p>
<pre>
// $Id: A0-1-2.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $
#include &lt;algorithm&gt;
#include &lt;cstdint&gt;
#include &lt;vector&gt;
std::uint8_t Fn1() noexcept
{
  return 0U;
}
void Fn2() noexcept
{
  std::uint8_t x = Fn1(); // Compliant
  Fn1(); // Non-compliant
  static_cast&lt;void&gt;(Fn1()); // Compliant by exception
}
void Fn3()
{
  std::vector&lt;std::int8_t&gt; v{0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5};
  std::unique(v.begin(), v.end()); // Non-compliant
  v.erase(std::unique(v.begin(), v.end()), v.end()); // Compliant
}
</pre>""",
}[id]


def report_info(id):
    return {
            'MISRA12_17.7': {
                'Category': 'Required'
            },
    }[id]

def test_entity(file):
    return True

def test_global():
    return False

def test_language(language):
    return language == 'C++'

def define_options(check):
    check.option().checkbox('unresolved', 'Include functions not defined in project (unresolved)', True)

def check(check, file):
    lexer = None


    # Gather refs depending on option
    unresolved = check.option().lookup('unresolved')
    if unresolved:
        refs = file.filerefs('Call ~inactive', 'Function')
    else:
        refs = file.filerefs('Call ~inactive', 'Function ~unresolved ~unknown')

    for ref in refs:
        # Skip any void function but not void pointer function
        if re.search('void', str(ref.ent().type())) and not re.search('void \*', str(ref.ent().type())):
            continue
        if not lexer:
            if not file.lexer():
                return
            lexer = file.lexer()
        lexeme = lexer.lexeme(ref.line(), ref.column())
        ok = False
        # Look for any for, while, if, switch statements
        while lexeme and not re.search(';|{|}', lexeme.text()):
            if lexeme.text() == ')':
                tempLex = Modules.findOpen(lexeme)
                if tempLex:
                    tempLex = tempLex.previous(True, True)
                    if tempLex and re.match('for|while|if|switch', tempLex.text()):
                        ok = False
                        break
            # Look for any for, while, if, switch statements or casts to void
            elif re.match('(void|for|while|if|switch)$', lexeme.text()) or re.search('=', lexeme.text()) or lexeme.token() == 'Preprocessor':
                ok = True
                break


            if lexeme:
                lexeme = lexeme.previous(True, True)

        if lexeme and not ok:
            check.violation(ref.ent(), file, ref.line(), ref.column(), ERR1, ref.file().name(), lexeme.line_begin(), lexeme.column_begin())
