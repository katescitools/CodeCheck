# This script is designed to run with Understand - CodeCheck


import re


ERR1 = 'Function is directly recursive.'
ERR2 = 'Function is indirectly recursive through %1.'


entKindString = 'ada entry, ada function, ada package, ada procedure, ada protected, ada task, c function, csharp method, fortran block data, fortran function, fortran interface, fortran program, fortran subroutine, java method, jovial file, jovial subroutine, pascal compunit, pascal function, pascal procedure, plm procedure, python function, vhdl procedure, vhdl function, vhdl process, vhdl architecture, web function, web method'

refKindString = 'ada call ~dispatch, c call ~virtual, c use ptr, csharp call ~virtual, csharp use ptr, fortran call, java call, jovial call, jovial asm use, pascal call ~virtual, plm call, python call, vhdl call, web call'


# The ID for the check
def ids():
    return ('A7-5-2', 'MISRA04_16.2', 'MISRA08_7-5-4', 'MISRA12_17.2', 'AC_01')


# The short name of the check
def name(id):
    return {
        'A7-5-2': 'Published Standards/AUTOSAR/Functions shall not call themselves, either directly or indirectly.',
        'MISRA04_16.2': 'Published Standards/MISRA-C 2004/16.2 Functions shall not call themselves, either directly or indirectly.',
        'MISRA08_7-5-4': 'Published Standards/MISRA-C++ 2008/7-5-4 Functions should not call themselves, either directly or indirectly.',
        'MISRA12_17.2': 'Published Standards/MISRA C 2012/17.2 Functions shall not call themselves, either directly or indirectly',
        'AC_01': 'All Checks/No Direct or Indirect Recursion',
    }[id]


def report_info(id):
    return {
        'A7-5-2': {
            'Automation': 'Automated',
            'Category':   'Required',
        },
        'MISRA04_16.2': {
            'Category': 'Required',
        },
        'MISRA08_7-5-4': {
            'Category': 'Advisory',
        },
        'MISRA12_17.2': {
            'Category': 'Required',
        },
    }[id]
    
# The long description of the check
def detailed_description(id):
    return {
        'A7-5-2': '''
<p>
Do not use function recursion.
</p>

<p><b>Rationale</b></p>

<p>
As the stack space is limited resource, use of recursion may lead to stack overflow at run-time. It also may limit the scalability and portability of the program.
</p>

<p>
Recursion can be replaced with loops, iterative algorithms or worklists.
</p>

<p><b>Exception</b></p>

<p>
Recursion in variadic template functions used to process template arguments does not violate this rule, as variadic template arguments are evaluated at compile time and the call depth is known.
</p>

<p>
Recursion of a constexpr function does not violate this rule, as it is evaluated at compile time.
</p>

<p><b>Example</b></p>

<pre>
// $Id: A7-5-2.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $
#include &lt;cstdint&gt;
static std::int32_t Fn1(std::int32_t number);
static std::int32_t Fn2(std::int32_t number);
static std::int32_t Fn3(std::int32_t number);
static std::int32_t Fn4(std::int32_t number);
std::int32_t Fn1(std::int32_t number)
{
    if (number &gt; 1)
    {
        number = number * Fn1(number - 1); // Non-compliant
    }

    return number;
}
std::int32_t Fn2(std::int32_t number)
{
    for (std::int32_t n = number; n &gt; 1; --n) // Compliant
    {
        number = number * (n - 1);
    }

    return number;
}
std::int32_t Fn3(std::int32_t number)
{
    if (number &gt; 1)
    {
        number = number * Fn3(number - 1); // Non-compliant
    }

    return number;
}
std::int32_t Fn4(std::int32_t number)
{
    if (number == 1)
    {
        number = number * Fn3(number - 1); // Non-compliant
    }

    return number;
}
template &lt;typename T&gt;
T Fn5(T value)
{
    return value;
}
template &lt;typename T, typename... Args&gt;
T Fn5(T first, Args... args)
{
    return first + Fn5(args...); // Compliant by exception - all of the
                                 // arguments are known during compile time
}
std::int32_t Fn6() noexcept
{
    std::int32_t sum = Fn5&lt;std::int32_t, std::uint8_t, float, double&gt;(
    10, 5, 2.5, 3.5); // An example call to variadic template function
    // ...
    return sum;
}
constexpr std::int32_t Fn7(std::int32_t x, std::int8_t n)
{
    if (n &gt;= 0)
    {
        x += x;
        return Fn5(x, --n); // Compliant by exception - recursion evaluated at
                            // compile time
    }
    return x;
}
</pre>

<p><b>See also</b></p>

<p>
• MISRA C++ 2008 [7]: Rule 7-5-4 Functions should not call themselves, either directly or indirectly.
</p>

<p>
• JSF December 2005 [8]: AV Rule 119 Functions shall not call themselves, either directly or indirectly (i.e. recursion shall not be allowed).
</p>

<p>
• HIC++ v4.0 [9]: 5.2.2 Ensure that functions do not call themselves, either directly or indirectly.
</p>

<p><b>Developer's Note:</b></p>

<p>
To reduce the amount of violations, non-recursive functions which call recursive functions will not be flagged. Only the recursive functions will be flagged as violations.
</p>

<p>
Understand doesn't have the capabilities to determine how a function pointer is used once it leaves scope, so this check is designed to throw a violation if a function uses its own function pointer in any way.
</p>
''',
        'MISRA04_16.2': '''
<p>
Do not use function recursion.
</p>

<p>
This means that recursive function calls cannot be used in safety-related systems. Recursion carries with it the danger of exceeding available stack space, which can be a serious error. Unless recursion is very tightly controlled, it is not possible to determine before execution what the worst-case stack usage could be.
</p>

<p><b>Developer's Note:</b></p>

<p>
To reduce the amount of violations, non-recursive functions which call recursive functions will not be flagged. Only the recursive functions will be flagged as violations.
</p>

<p>
Understand doesn't have the capabilities to determine how a function pointer is used once it leaves scope, so this check is designed to throw a violation if a function uses its own function pointer in any way.
</p>
''',
        'MISRA08_7-5-4': '''
<p>
Do not use function recursion.
</p>

<p><b>Rationale</b></p>

<p>
Unbounded recursion is likely to lead to a stack over-flow and may impact system timings. This is also the case for an iterative algorithm.
</p>

<p><b>Example</b></p>

<pre>
int32_t fn ( int32_t x )
{
    if ( x &gt; 0 )
    {
        x = x * fn ( x - 1 );      // Non-compliant
    }
    return ( x );
}
// File1.cpp
int32_t fn_2 ( int32_t x )
{
    if ( x &gt; 0 )
    {
        x = x * fn_3 ( x - 1 );    // Non-compliant
    }
    return ( x );
}
// File2.cpp
int32_t fn_3 ( int32_t x )
{
    if ( x == 0 )
    {
        x = x * fn_2 ( x - 1 );    // Non-compliant
    }
    return ( x );
}
</pre>

<p><b>Developer's Note:</b></p>

<p>
To reduce the amount of violations, non-recursive functions which call recursive functions will not be flagged. Only the recursive functions will be flagged as violations.
</p>

<p>
Understand doesn't have the capabilities to determine how a function pointer is used once it leaves scope, so this check is designed to throw a violation if a function uses its own function pointer in any way.
</p>
''',

        'MISRA12_17.2': '''
<p>
Do not use function recursion.
</p>

<p><b>Rationale</b></p>

<p>
Recursion carries with it the danger of exceeding available stack space, which can lead to a serious failure. Unless recursion is very tightly controlled, it is not possible to determine before execution what the worst-case stack usage could be.
</p>

<p><b>Developer's Note:</b></p>

<p>
To reduce the amount of violations, non-recursive functions which call recursive functions will not be flagged. Only the recursive functions will be flagged as violations.
</p>

<p>
Understand doesn't have the capabilities to determine how a function pointer is used once it leaves scope, so this check is designed to throw a violation if a function uses its own function pointer in any way.
</p>
''',

        'AC_01': '''
<p>
Do not use function recursion.
</p>

<p>
This means that recursive function calls cannot be used in safety-related systems. Recursion carries with it the danger of exceeding available stack space, which can be a serious error. Unless recursion is very tightly controlled, it is not possible to determine before execution what the worst-case stack usage could be.
</p>

<p><b>Developer's Note:</b></p>

<p>
To reduce the amount of violations, non-recursive functions which call recursive functions will not be flagged. Only the recursive functions will be flagged as violations.
</p>

<p>
Understand doesn't have the capabilities to determine how a function pointer is used once it leaves scope, so this check is designed to throw a violation if a function uses its own function pointer in any way.
</p>
''',
    }[id]


# Tests the type of file
def test_entity(file):
    return True


def test_global():
    return False


def test_language(language):
    return language in {'Ada', 'C++', 'C#', 'Fortran', 'Java', 'Jovial', 'Pascal', 'Plm', 'Python', 'VHDL', 'Web'}


def define_options(check):
    check.options().integer('limit', 'Enter recursion limit for checking indirect recursion (lower numbers will increase speed of check, enter 0 for infinite)', 0)


def variadicTemplateFunction(ent):
    return ent.parameters() and re.search(',Args... ', ent.parameters())


def constExprFunction(ent):
    return ent.contents() and re.match('constexpr ', ent.contents())


def exception(ent):
    return variadicTemplateFunction(ent) or constExprFunction(ent)


def discoverRecursion(check, ent, count, firstTime, seen, originalEnt):
    if not ent.kind().check(entKindString):
        return

    limit = check.option().lookup('limit')

    if limit > 0:
        count += 1

    for callRef in ent.refs(refKindString, entKindString, True):
        callEnt = callRef.ent()
        if callEnt.id() not in seen:
            seen[callEnt.id()] = 0
        seen[callEnt.id()] += 1
        if seen[callEnt.id()] > 1:
            continue

        if callEnt.id() == originalEnt.id() and not exception(originalEnt):
            if firstTime:
                check.violation(originalEnt, callRef.file(), callRef.line(), callRef.column(), ERR1)
            else:
                check.violation(originalEnt, callRef.file(), callRef.line(), callRef.column(), ERR2, originalEnt.longname())
            return

        if limit != 0 and count < limit:
            return
        discoverRecursion(check, callEnt, count, False, seen, originalEnt)
        count -= 1

    return


def check(check, file):
    for ref in file.filerefs('define, body declare', entKindString, True):
        ent = ref.ent()
        count = 0
        firstTime = True
        seen = {}
        originalEnt = ent

        discoverRecursion(check, ent, count, firstTime, seen, originalEnt)
