# This script is designed to run with Understand - CodeCheck
# Written by Kyle Jackson
# 1-22-15
# Rewritten by Robby Bennett
# 11-28-22

import re


ERR1 = 'Implicit values and explicitly values for this enumeration overlap'


def ids():
    return ('MISRA12_8.12', 'CPP_D028')


def name(id):
    return {
        'MISRA12_8.12': 'Published Standards/MISRA C 2012/8.12 Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique',
        'CPP_D028': 'All Checks/Language Specific/C and C++/Declarations and Definitions/Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique',
    }[id]


def detailed_description():
    return '''

<p><b>Rationale</b></p>

<p>
An implicitly-specified enumeration constant has a value 1 greater than its
predecessor. If the first enumeration constant is implicitly-specified then its
value is 0.
</p>

<p>
An explicitly-specified enumeration constant has the value of the associated
constant expression.
</p>

<p>
If implicitly-specified and explicitly-specified constants are mixed within an
enumeration list, it is possible for values to be replicated. Such replication
may be unintentional and may give rise to unexpected behaviour.
</p>

<p>
This rule requires that any replication of enumeration constants be made
explicit, thus making the intent clear.
</p>

<p><b>Example</b></p>

<p>
In the following examples the green and yellow enumeration constants are given
the same value.
</p>

<pre>
  /* Non-compliant - yellow replicates implicit green */
  enum colour { red = 3, blue, green, yellow = 5 }
  /* Compliant                                        */
  enum colour { red = 3, blue, green = 5, yellow = 5 }
</pre>
'''


def test_entity(file):
    return file.kind().check('Code File, Header File')


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def intOrZero(lexeme):
    try:
        return int(lexeme.text())
    except:
        return 0


def check(check, file):
    for enum in file.filerefs('Define', 'Enum Type'):

        # Test to see if implicit values are event used
        # Setup variables needed for tracking
        tempLexeme = file.lexer(False).lexeme(enum.line(), enum.column())
        implicitValue = False
        equalSeen = False

        # While we are looking at this set of enumerators
        while tempLexeme and tempLexeme.text() != ';':

            # Test to see if implicit values are being used
            if tempLexeme.text() == '=':
                equalSeen = True
            elif tempLexeme.text() == ',' :
                if equalSeen:
                    equalSeen = False
                else:
                    implicitValue = True
                    break
            tempLexeme = tempLexeme.next(True, True)

        # Skip of no implicit values are used
        if not implicitValue:
            continue

        # Setup variables needed for tracking
        lexeme = file.lexer().lexeme(enum.line(), enum.column())
        impliedValue = 0
        lastAssignment = 0
        currentEnum = enum

        # While we are looking at this set of enumerators
        while lexeme and lexeme.text() != ';':

            # If we see an explicit assignment
            if lexeme.text() == '=':

                # Look at our assignment value. If it is less than what we
                # expect via impliedValue but doesn't match our last assigned
                # value, throw an error
                lexeme = lexeme.next(True, True)
                currentAssignment = intOrZero(lexeme)
                if currentAssignment < impliedValue and currentAssignment != lastAssignment and not re.match(r'0x', lexeme.text()):
                    check.violation(currentEnum.ent(), currentEnum.file(), currentEnum.line(), currentEnum.column(), ERR1)

                # Track the last value we assigned and our expected value
                lastAssignment = impliedValue
                impliedValue = intOrZero(lexeme)

            # Track our progress through the enumerators list and increment our
            # impliedValue as neccissary
            if lexeme.token() == 'Identifier':
                currentEnum = lexeme.ref()
            elif lexeme.text() == ',':
                impliedValue += 1
            lexeme = lexeme.next(True, True)
