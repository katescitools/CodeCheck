ERR1 = 'New parameter identifier "%1" different from original "%2"'


# The ID for the check
def ids():
    return ('M8-4-2', 'MISRA08_8-4-2', 'CPP_D052')


# The short name of the check
def name(id):
    return {
        'M8-4-2': 'Published Standards/AUTOSAR/The identifiers used for the parameters in a re-declaration of a function shall be identical to those in the declaration.',
        'MISRA08_8-4-2': 'Published Standards/MISRA-C++ 2008/8-4-2 Use the same identifier in definition and declaration of functions.',
        'CPP_D052': 'All Checks/Language Specific/C and C++/Declarations and Definitions/Use the same identifier in definition and declaration of functions.',
    }[id]


# The long description of the check
def detailed_description():
    return '''
<p>When re-declaring a function, do not change the identifiers of the parameters.</p>

<p><b>Rationale</b></p>

<p>
The name given to a parameter helps document the purpose of the parameter within the function body. If a function parameter is renamed in a subsequent re-declaration, then having different names for the same object will probably lead to developer confusion.
</p>

<p>Note that the rule also applies to any overriding set.</p>

<p><b>Exception</b></p>

<p>It is not a violation of this rule if the declaration or re-declaration contains an unnamed parameter.</p>

<p><b>Example</b></p>

<pre>
// File1
void CreateRectangle ( uint32_t Height, uint32_t Width );
// File2
// Non-compliant
void CreateRectangle ( uint32_t Width, uint32_t Height );
void fn1 ( int32_t a );
void fn2 ( int32_t   );
void fn1 ( int32_t b )   // Non-compliant
{
}
void fn2 ( int32_t b )   // Compliant
{
}
</pre>
'''


# Tests the type of file
def test_entity(file):
    return file.kind().check('code file, header file')


def test_global():
    return True


def test_language(language):
    return language == 'C++'


def define_options(check):
    check.options().checkbox('ignoreAdditionalForSameFunction', 'Ignore additional violations for the same function', False)


def normal_identifier(lexeme):
    if not lexeme or lexeme.token() != 'Identifier' or (lexeme.ent() and not lexeme.ent().kind().check('Parameter')):
        return False
    return True


def check(check):
    for func_ent in check.db().ents('Function ~Lambda'):
        param_count = len(func_ent.refs('Declare, Define', 'Parameter', True))
        param_refs = func_ent.refs('Declare, Define', 'Parameter', False)

        # Get original parameters
        original_params = []
        for i in range(0, param_count):
            param_ref = param_refs[i]

            lexeme = param_ref.file().lexer().lexeme(param_ref.line(), param_ref.column())
            if normal_identifier(lexeme):
                original = lexeme.text()
            else:
                original = '[unnamed]'

            original_params.append(original)

        # Compare next parameters
        for i in range(param_count, len(param_refs)):
            param_ref = param_refs[i]

            lexeme = param_ref.file().lexer().lexeme(param_ref.line(), param_ref.column())
            if not normal_identifier(lexeme):
                continue

            original = original_params[i % param_count]
            current = lexeme.text()

            if current != original and original != '[unnamed]':
                check.violation(func_ent, param_ref.file(), param_ref.line(), param_ref.column(), ERR1, current, original)
                if check.options().lookup('ignoreAdditionalForSameFunction'):
                    break
