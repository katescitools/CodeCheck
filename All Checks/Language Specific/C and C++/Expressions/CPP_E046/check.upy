# This script is designed to run with Understand - CodeCheck
# Written by Robby Bennett
# 3-9-22


import re


ERR1 = 'Right operand %1 is negative'
ERR2 = 'Right operand %1 can be equal to the width of the left hand operand'
ERR3 = 'Right operand %1 can be greater than the width of the left hand operand %2'


# Dictionary of all minimum sizes in bits, not always true for all compilers and target platforms
widths = {'char': 8, 'signed char': 8, 'unsigned char': 8, 'short': 16, 'short int': 16, 'signed short': 16, 'signed short int': 16, 'unsigned short': 16, 'unsigned short int': 16, 'int': 16, 'signed': 16, 'signed int': 16, 'unsigned': 16, 'unsigned int': 16, 'size_t': 16, 'long': 32, 'long int': 32, 'signed long': 32, 'signed long int': 32, 'unsigned long': 32, 'unsigned long int': 32, 'long long': 64, 'long long int': 64, 'signed long long': 64, 'signed long long int': 64, 'unsigned long long': 64, 'unsigned long long int': 64, '16 bit pointer': 16, '32 bit pointer': 32, '64 bit pointer': 64}


def ids():
    return ('M5-8-1', 'MISRA08_5-8-1', 'CPP_E046', 'MISRA04_12.8', 'MISRA12_12.2')


def name(id):
    return {
        'M5-8-1': 'Published Standards/AUTOSAR/The right hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left hand operand.',
        'MISRA08_5-8-1': 'Published Standards/MISRA-C++ 2008/5-8-1 The right hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left hand operand.',
        'CPP_E046': 'All Checks/Language Specific/C and C++/Expressions/The right hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left hand operand.',
        'MISRA04_12.8': 'Published Standards/MISRA-C 2004/12.8 The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand.',
        'MISRA12_12.2': 'Published Standards/MISRA C 2012/12.2 The right hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left hand operand.',
    }[id]


def detailed_description(id):
    return {
        'M5-8-1': '''
<p>
The right hand operand of a shift operator cannot be negative, or greater than or equal to the bit size of the left hand operand.
</p>

<p><b>Rationale</b></p>

<p>
It is undefined behaviour if the right hand operand is negative, or greater than or equal to the width of the left hand operand.
</p>

<p>
If, for example, the left hand operand of a left-shift or right-shift is a 16-bit integer, then it is important to ensure that this is shifted only by a number between 0 and 15 inclusive.
</p>

<p>
There are various ways of ensuring that this rule is followed. The simplest is for the right hand operand to be a constant (whose value can then be statically checked). Use of an unsigned integer type will ensure that the operand is non-negative, so then only the upper limit needs to be checked (dynamically at run time or by review). Otherwise both limits will need to be checked.
</p>

<p><b>Example</b></p>

<pre>
u8a  = (uint8_t) ( u8a &lt;&lt; 7 );              // Compliant
u8a  = (uint8_t) ( u8a &lt;&lt; 9 );              // Non-compliant
u16a = (uint16_t)( (uint16_t) u8a &lt;&lt; 9 );   // Compliant
</pre>

<p><b>See also</b></p>

<p>
See Section 6.5.0 for a description of underlying type.
</p>

<p><b>Developer's note</b></p>

<p>
1. While MISRA 2012 Rule 12.2 says the essential type of <code>1u</code> is <code>unsigned char</code>, the official documentation actually has always defined it as a variant type defined by the compiler, with a minimum bit width of <code>sizeof(unsigned int) * 8</code>. The same is for <code>1</code> with a minimum bit width of <code>sizeof(int) * 8</code>. Therefore, for reducing false positives, it is recommended to uncheck the option "Treat literal int as char".
</p>

<p>
2. The bit width of the left hand operand may be larger on certain target systems. This check assumes the minimum bit width allowed of each type.
</p>
''',

        'MISRA08_5-8-1': '''
<p>
The right hand operand of a shift operator cannot be negative, or greater than or equal to the bit size of the left hand operand.
</p>

<p><b>Rationale</b></p>

<p>
It is undefined behaviour if the right hand operand is negative, or greater than or equal to the width of the left hand operand.
</p>

<p>
If, for example, the left hand operand of a left-shift or right-shift is a 16-bit integer, then it is important to ensure that this is shifted only by a number between 0 and 15 inclusive.
</p>

<p>
There are various ways of ensuring that this rule is followed. The simplest is for the right hand operand to be a constant (whose value can then be statically checked). Use of an unsigned integer type will ensure that the operand is non-negative, so then only the upper limit needs to be checked (dynamically at run time or by review). Otherwise both limits will need to be checked.
</p>

<p><b>Example</b></p>

<pre>
u8a  = (uint8_t) ( u8a &lt;&lt; 7 );              // Compliant
u8a  = (uint8_t) ( u8a &lt;&lt; 9 );              // Non-compliant
u16a = (uint16_t)( (uint16_t) u8a &lt;&lt; 9 );   // Compliant
</pre>

<p><b>See also</b></p>

<p>
See Section 6.5.0 for a description of underlying type.
</p>

<p><b>Developer's note</b></p>

<p>
1. While MISRA 2012 Rule 12.2 says the essential type of <code>1u</code> is <code>unsigned char</code>, the official documentation actually has always defined it as a variant type defined by the compiler, with a minimum bit width of <code>sizeof(unsigned int) * 8</code>. The same is for <code>1</code> with a minimum bit width of <code>sizeof(int) * 8</code>. Therefore, for reducing false positives, it is recommended to uncheck the option "Treat literal int as char".
</p>

<p>
2. The bit width of the left hand operand may be larger on certain target systems. This check assumes the minimum bit width allowed of each type.
</p>
''',
        'CPP_E046': '''
<p>
The right hand operand of a shift operator cannot be negative, or greater than or equal to the bit size of the left hand operand.
</p>

<p><b>Rationale</b></p>

<p>
It is undefined behaviour if the right hand operand is negative, or greater than or equal to the width of the left hand operand.
</p>

<p>
If, for example, the left hand operand of a left-shift or right-shift is a 16-bit integer, then it is important to ensure that this is shifted only by a number between 0 and 15 inclusive.
</p>

<p>
There are various ways of ensuring that this rule is followed. The simplest is for the right hand operand to be a constant (whose value can then be statically checked). Use of an unsigned integer type will ensure that the operand is non-negative, so then only the upper limit needs to be checked (dynamically at run time or by review). Otherwise both limits will need to be checked.
</p>

<p><b>Example</b></p>

<pre>
u8a  = (uint8_t) ( u8a &lt;&lt; 7 );              // Compliant
u8a  = (uint8_t) ( u8a &lt;&lt; 9 );              // Non-compliant
u16a = (uint16_t)( (uint16_t) u8a &lt;&lt; 9 );   // Compliant
</pre>

<p><b>See also</b></p>

<p>
See Section 6.5.0 for a description of underlying type.
</p>

<p><b>Developer's note</b></p>

<p>
1. While MISRA 2012 Rule 12.2 says the essential type of <code>1u</code> is <code>unsigned char</code>, the official documentation actually has always defined it as a variant type defined by the compiler, with a minimum bit width of <code>sizeof(unsigned int) * 8</code>. The same is for <code>1</code> with a minimum bit width of <code>sizeof(int) * 8</code>. Therefore, for reducing false positives, it is recommended to uncheck the option "Treat literal int as char".
</p>

<p>
2. The bit width of the left hand operand may be larger on certain target systems. This check assumes the minimum bit width allowed of each type.
</p>
''',

        'MISRA04_12.8': '''
<p>
The right hand operand of a shift operator cannot be negative, or greater than or equal to the bit size of the left hand operand.
</p>

<p><b>Rationale</b></p>

<p>
If, for example, the left hand operand of a left-shift or right-shift is a 16-bit integer, then it is important to ensure that this is shifted only by a number between 0 and 15 inclusive.
</p>

<p>
See section 6.10 for a description of underlying type.
</p>

<p>
There are various ways of ensuring that this rule is followed. The simplest is for the right hand operand to be a constant (whose value can then be statically checked). Use of an unsigned integer type will ensure that the operand is non-negative, so then only the upper limit needs to be checked (dynamically at run time or by review). Otherwise both limits will need to be checked.
</p>

<pre>
u8a  = (uint8_t) ( u8a &lt;&lt; 7 );              // Compliant
u8a  = (uint8_t) ( u8a &lt;&lt; 9 );              // Non-compliant
u16a = (uint16_t)( (uint16_t) u8a &lt;&lt; 9 );   // Compliant
</pre>

<p><b>Developer's note</b></p>

<p>
1. While MISRA 2012 Rule 12.2 says the essential type of <code>1u</code> is <code>unsigned char</code>, the official documentation actually has always defined it as a variant type defined by the compiler, with a minimum bit width of <code>sizeof(unsigned int) * 8</code>. The same is for <code>1</code> with a minimum bit width of <code>sizeof(int) * 8</code>. Therefore, for reducing false positives, it is recommended to uncheck the option "Treat literal int as char".
</p>

<p>
2. The bit width of the left hand operand may be larger on certain target systems. This check assumes the minimum bit width allowed of each type.
</p>
''',

        'MISRA12_12.2': '''
<p>
The right hand operand of a shift operator cannot be negative, or greater than or equal to the bit size of the left hand operand.
</p>

<p><b>Rationale</b></p>

<p>
If the right hand operand is negative, or greater than or equal to the width of the left hand operand, then the behaviour is undefined.
</p>

<p>
If, for example, the left hand operand of a left-shift or right-shift is a 16-bit integer, then it is important to ensure that this is shifted only by a number in the range 0 to 15.
</p>

<p>
See Section 8.10 for a description of essential type and the limitations on the essential types for the operands of shift operators.
</p>

<p>
There are various ways of ensuring this rule is followed. The simplest is for the right hand operand to be a constant (whose value can then be statically checked). Use of an unsigned integer type will ensure that the operand is non-negative, so then only the upper limit needs to be checked (dynamically at run time or by review). Otherwise both limits will need to be checked.
</p>

<p><b>Example</b></p>

<pre>
u8a = u8a &lt;&lt; 7;                 /* Compliant */
u8a = u8a &lt;&lt; 8;                 /* Non-compliant */
u16a = ( uint16_t ) u8a &lt;&lt; 9;   /* Compliant */
</pre>

<p>
To assist in understanding the following examples, it should be noted that the <i>essential type</i> of <code>1u</code> is <i>essentially unsigned char</i>, whereas the <i>essential type</i> of <code>1UL</code> is <i>essentially unsigned long</i>.
</p>

<pre>
1u &lt;&lt; 10u;                      /* Non-compliant */
( uint16_t ) 1u &lt;&lt; 10u;         /* Compliant */
1UL &lt;&lt; 10u;                     /* Compliant */
</pre>

<p><b>Developer's note</b></p>

<p>
1. While MISRA 2012 Rule 12.2 says the essential type of <code>1u</code> is <code>unsigned char</code>, the official documentation actually has always defined it as a variant type defined by the compiler, with a minimum bit width of <code>sizeof(unsigned int) * 8</code>. The same is for <code>1</code> with a minimum bit width of <code>sizeof(int) * 8</code>. Therefore, for reducing false positives, it is recommended to uncheck the option "Treat literal int as char".
</p>

<p>
2. The bit width of the left hand operand may be larger on certain target systems. This check assumes the minimum bit width allowed of each type.
</p>
''',
    }[id]


def test_entity(file):
    return file.kind().check('header file, code file')


def test_global():
    return False


def define_options(check):
    check.options().choice('architecture', 'Minimum architecture for target systems', ['16 bit', '32 bit', '64 bit'], '32 bit')
    check.options().checkbox('treatIntAsChar', 'Treat literal int as char (see note 1)', True)


def test_language(language):
    return language == 'C++'


def literalOrConst(lex):
    return lex.token() == 'Literal' or lex.token() == 'Identifier' and lex.ent() and lex.ent().type() and re.match('const ', lex.ent().type())


def integerLiteral(string):
    return re.match('-?\d+\w*$', str(string))


def widthFromValue(string, treatIntAsChar):
    string = string.lower()

    # Count the amount of integer suffix characters in the last 3 characters
    counts = {'u': 0, 'l': 0, 'z': 0}
    for char in string[-3:]:
        if char in counts:
            counts[char] += 1

    # Get the minimum width of the suffixes
    if counts == {'u': 0, 'l': 0, 'z': 0}:
        if treatIntAsChar:
            return widths['char']
        else:
            return widths['int']
    elif counts == {'u': 1, 'l': 0, 'z': 0}:
        if treatIntAsChar:
            return widths['unsigned char']
        else:
            return widths['unsigned int']
    elif counts == {'u': 0, 'l': 1, 'z': 0}:
        return widths['long int']
    elif counts == {'u': 1, 'l': 1, 'z': 0}:
        return widths['unsigned long int']
    elif counts == {'u': 0, 'l': 2, 'z': 0}:
        return widths['long long int']
    elif counts == {'u': 0, 'l': 2, 'z': 0}:
        return widths['long long int']
    elif counts == {'u': 1, 'l': 2, 'z': 0}:
        return widths['unsigned long long int']
    elif counts == {'u': 0, 'l': 0, 'z': 1}:
        return widths['size_t']
    elif counts == {'u': 1, 'l': 0, 'z': 1}:
        return widths['size_t']


def literalToInteger(literal):
    literal = literal.lower()

    # Remove suffix from the last 3 characters
    length = len(literal)
    start = length - 3
    if start < 0:
        start = 0
    for i in range(start, length):
        char = literal[i]
        if char in {'u', 'l', 'z'}:
            literal = literal[0:i]
            break

    # Binary
    if re.match('0b[0|1]+$', literal):
        return int(literal, 2)
    # Octal
    if re.match('0[0-7]*$', literal):
        return int(literal, 8)
    # Decimal
    if re.match('-?[1-9][0-9]*$', literal):
        return int(literal)
    # Hexadecimal
    if re.match('0x[0-9|a-f]+$', literal):
        return int(literal, 16)


def widthFromType(lexeme):
    if lexeme.token() == 'Identifier' and lexeme.ent() and lexeme.ent().kindname() == 'Typedef' and lexeme.ent().freetext('UnderlyingType'):
        return widths[lexeme.ent().freetext('UnderlyingType')]
    if lexeme.token() == 'Keyword' and lexeme.text() in widths:
        return widths[lexeme.text()]
    return None

def widthFromCStyleCast(lexeme):
    # Match )
    lexeme = lexeme.previous(True, True)
    if lexeme.token() != 'Punctuation' or lexeme.text() != ')':
        return None

    # Match a type
    lexeme = lexeme.previous(True, True)
    return widthFromType(lexeme)


def check(check, file):
    lexer = file.lexer()

    if not lexer or not re.search('<<|>>', file.contents()):
        return

    lex = lexer.first()

    treatIntAsChar = check.options().lookup('treatIntAsChar')

    # Find all the bitshift operators
    while lex:
        if lex.text() in {'<<', '>>'} and lex.token() == 'Operator':
            lLex = lex.previous(True, True)
            lEnt = lLex.ent()
            lWidth = None
            rLex = lex.next(True, True)
            rEnt = rLex.ent()
            rValue = None

            # Skip if the right lexeme isn't a literal or a constant object
            if not literalOrConst(rLex):
                lex = lex.next(True, True)
                continue

            # Get the width of the left hand operand if it's not a literal
            if lEnt:
                lType = lEnt.freetext('UnderlyingType')
                # If it's a pointer, the size is usually defined by the architecture.
                # The minimum arhitecture is used as an edge case for the smallest width.
                if lType and re.search('\*$', lType):
                    lType = check.options().lookup('architecture') + ' pointer'
                # If it's a normal integer or pointer
                if lType in widths:
                    lWidth = widths[lType]
                # If it's a resolved macro which is an integer literal
                elif lEnt.kind().check('~Unresolved Macro'):
                    value = lEnt.value()
                    if integerLiteral(value):
                        lWidth = widthFromValue(value, treatIntAsChar)
            # Get the width of the left hand operand if it's a literal
            elif lLex.token() == 'Literal' and integerLiteral(lLex.text()):
                value = lLex.text()
                lWidth = widthFromValue(value, treatIntAsChar)

            # Change the width of the left hand operand if there's a cast
            castWidth = widthFromCStyleCast(lLex)
            if castWidth:
                lWidth = castWidth

            # Get the value of the right operand if it's a constant object
            if rEnt and rEnt.value() and integerLiteral(rEnt.value()):
                rValue = literalToInteger(rEnt.value())
            # Get the value of the right operand if it's a literal
            elif integerLiteral(rLex.text()):
                rValue = literalToInteger(rLex.text())

            if rValue:
                if rValue < 0:
                    check.violation(rEnt, file, rLex.line_begin(), rLex.column_begin(), ERR1, rValue)
                elif lWidth and rValue == lWidth:
                    check.violation(rEnt, file, rLex.line_begin(), rLex.column_begin(), ERR2, rValue)
                elif lWidth and rValue > lWidth:
                    check.violation(rEnt, file, rLex.line_begin(), rLex.column_begin(), ERR3, rValue, lWidth)

        lex = lex.next(True, True)
