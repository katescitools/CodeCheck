# This script is designed to run with Understand - CodeCheck
# Written by Jason Quinn
# 2-8-2022
import re
import Modules

ERR1 = 'Comma operator was used'

def ids():
    return ('M5-18-1', 'CPP_E049')

def name(id):
    return {
        'M5-18-1': """\
Published Standards/AUTOSAR/The comma operator shall not be used.""",
        'CPP_E049': """\
All Checks/Language Specific/C and C++/Expressions/The comma operator shall not be
used."""

    }[id]

def detailed_description():
    return """\
<p><b>Rationale</b></p>
<p> The comma operator (represented by the token , ) is a binary operator that
evaluates its first operand and discards the result, it then evaluates the
second operand and returns this value (and type). The comma operator has the
lowest precedence of any C operator, and acts as a sequence point.</p>
<p>Use of the comma operator is generally detrimental to the readability of
code, and the same effect can be achieved by other means.</p>
<p><b>Example</p></b>
<pre>
f ( ( 1, 2 ), 3 ); // Non-compliant â€“ how many parameters?
</pre>"""

def test_entity(file):
    return file.kind().check('code file, header file')

def test_language(language):
    return language == 'C++'


def check(check, file):
    lexer = file.lexer()
    if not lexer:
        return

    lexeme = lexer.first()
    equals = False

    while lexeme:
        if (lexeme.ent() and re.search('function|macro|object', lexeme.ent().kindname().lower())) or re.search('for', lexeme.text()):
            lexeme = lexeme.next(True, True)
            if lexeme and lexeme.text() == '(':
                lexeme = recurse(lexeme, True, check, file)

        elif lexeme.text() == '(':
            lexeme = recurse(lexeme, False, check, file)
        elif lexeme.text() == '{':
            prevLex = lexeme.previous(True, True)
            if prevLex and (prevLex.text() == '=' or (prevLex.ent() and re.search('Enum', prevLex.ent().kindname()))):
                lexeme = Modules.findClose(lexeme)
            else:
                lexeme = lexeme.next(True, True)
        elif lexeme.text() == '=':
            equals = True
            lexeme = lexeme.next(True, True)
        elif lexeme.text() == ';':
            equals = False
            lexeme = lexeme.next(True, True)
        elif lexeme.text() == ',' and equals:
            check.violation(file, file, lexeme.line_begin(), lexeme.column_begin(), ERR1)
            lexeme = lexeme.next(True, True)
                
        else:
            lexeme = lexeme.next(True, True)


# Recurses through nested parenthesis and determines whether or not the comma is used as
# a binary operator or a function parameter
def recurse(lexeme, funParen, check, file):
    if not lexeme:
        return None
    close = Modules.findClose(lexeme)
    if not close:
        return None
    lexeme = lexeme.next(True, True)
    while lexeme and not (lexeme.line_begin() == close.line_begin() and lexeme.column_begin() == close.column_begin()):
        if (lexeme.ent() and re.search('function|macro|object', lexeme.ent().kindname().lower())) or re.search('for', lexeme.text()):
            lexeme = lexeme.next(True, True)
            if lexeme and lexeme.text() == '(':
                lexeme = recurse(lexeme, True, check, file)

        elif lexeme.text() == '(':
            lexeme = recurse(lexeme, False, check, file)

        elif lexeme.text() == ',' and not funParen:
            check.violation(file, file, lexeme.line_begin(), lexeme.column_begin(), ERR1)
            lexeme = lexeme.next(True, True)

        else:
            lexeme = lexeme.next(True, True)

    return lexeme

