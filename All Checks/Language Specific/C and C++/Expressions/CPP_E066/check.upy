# This script is designed to run with Understand - CodeCheck
# Written by Jason Quinn
# 5-17-2021
import re
import Modules

ERR1 = 'Const should be placed on the left-hand side of the comparison'

def id():
    return 'CPP_E066'

def name():
    return """\
All Checks/Language Specific/C and C++/Expressions/Const Should be placed on the
left-hand side of the comparison"""

def detailed_description():
    return """\
<p>When coding a conditional statement where a comparision is made to a
constant, it is recommended that the constant be placed on the left-hand side
of the comparison in order to cause the compiler to generate an error in cases
where a typo is made when inserting the conditional operator.</p>
<p>For example:</p>
<pre>
const int max     = 10;
      int current = 5;
if (current = max) { // Error, operator should be one of >=, <=, !=, or ==
    ...
}</pre>
<p>In the case above an error has been inserted and will only be caught by a
review of the code. Using the recommended method of programming conditionals as
follows the error will be caught by the compiler:</p>
<pre>
const int max     = 10;
      int current = 5;

if (max = current) { // Error, but an error message will be generated by the
    ...              // compiler due to an assignment to a constant.
}</pre>"""

def test_entity(file):
    return file.kind().check('code file, header file')

def test_language(language):
    return language == 'C++'

def check(check, file):
    lexer = None
    # Gather refs
    consts = file.filerefs('Assign Value, Use', 'Object')

    for const in consts:
        # Check if const
        if re.search('const', str(const.ent().type())):
            # Create lexer
            if not lexer:
                lexer = file.lexer()

            lexeme = lexer.lexeme(const.line(), const.column())
            prevLex = lexeme

            # Go through use refs
            if const.kindname() == 'Use':
                prevLex = prevLex.previous(ignore_whitespace=True, ignore_comments=True)
                # Check for the following comparative operators
                if re.match('==|!=|<=|>=', prevLex.text()):
                    prevLex = prevLex.previous(ignore_whitespace=True, ignore_comments=True)
                    if prevLex.ent() and re.search('const', prevLex.ent().type()):
                        continue
                else:
                    continue
            # Look for if statements or while loops
            while prevLex and not re.match('if|while|;|}|{', prevLex.text()):
                if prevLex.text() == ')':
                    prevLex = Modules.findOpen(prevLex)

                prevLex = prevLex.previous(ignore_comments=True, ignore_whitespace=True)
                if prevLex and prevLex.ent() and re.search('const', str(prevLex.ent().type())):
                    break


            lexeme = lexeme.next(ignore_whitespace=True, ignore_comments=True)

            # Throw violation
            if prevLex and re.match('if|while', prevLex.text()) or lexeme.text() == '?' or (lexeme.text() == ')' and lexeme.next(ignore_whitespace=True, ignore_comments=True).text() == '?'):
                check.violation(const.ent(), file, lexeme.line_begin(), lexeme.column_begin(), ERR1)

    
