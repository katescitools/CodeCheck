import re

ERR1 = 'Integer converted to pointer.'
ERR2 = 'Pointer to void converted to another pointer type.'

# The ID for the check
def ids():
    return ('M5-2-8', 'MISRA08_5-2-8', 'CPP_T022')

# The short name of the check
def name(id):
    return {
        'M5-2-8': 'Published Standards/AUTOSAR/An object with integer type or pointer to void type shall not be converted to an object with pointer type.',
        'MISRA08_5-2-8': 'Published Standards/MISRA-C++ 2008/5-2-8 An object with integer type or pointer to void type shall not be converted to an object with pointer type.',
        'CPP_T022': 'All Checks/Language Specific/C and C++/Types/An object with integer type or pointer to void type shall not be converted to an object with pointer type.',
    }[id]

# The long description of the check
def detailed_description():
    return '''
<p><b>Rationale</b></p>

<p>
In general, converting from an integral type or a pointer to <i>void</i> type to a pointer to an object leads to <i>unspecified behaviour</i>.
</p>

<p><b>Example</b></p>

<pre>
struct S
{
    int32_t i;
    int32_t j;
};
void f ( void * v, int32_t i )
{
    S * s1 = reinterpret_cast&lt;S *&gt;( v ); // Non-compliant
    S * s2 = reinterpret_cast&lt;S *&gt;( i ); // Non-compliant
}
</pre>
'''

# Tests the type of file
def test_entity(file):
    return file.kind().check('header file,code file')

# Optional - Return True if this check should be run on the entire project
# regardless of what files are selected. Should only be used for
# project-level checks
def test_global():
    return False

def test_language(language):
    return language == 'C++'

def is_ptr_type(type):
    return True if re.search(r"\*", type) else False

def is_int_type(ent):
    return True if re.search(r"int", str(get_base_type_int(ent))) else False

def is_void_ptr_type(ent):
    if is_ptr_type(ent.type()):
        return True if re.search(r"void", str(get_base_type_void(ent))) else False
    else:
        return True if re.search(r"void \*", str(get_base_type_void(ent))) else False

def get_base_type_void(ent):
    if re.search(r"void", str(ent.type())):
        return str(ent.type())
    elif ent.ref("Typed") and ent.ref("Typed").ent():
        return get_base_type_void(ent.ref("Typed").ent())

def get_base_type_int(ent):
    if re.search(r"int", str(ent.type())):
        return str(ent.type())
    elif ent.ref("Typed") and ent.ref("Typed").ent():
        return get_base_type_int(ent.ref("Typed").ent())

def check(check, file):
    #get all local obj
    for ref in file.filerefs("Define","~Unresolved ~Unknown Object", True):
        # check if object is a ptr and being assign with ptr object
        if ref.ent().ref("C Assign Ptr") and is_ptr_type(str(ref.ent().type())):
            # get object used for C Assign Ptr
            ptr_assigned = ref.ent().ref("C Assign Ptr")
            # if ptr_assigned is an integer or void ptr
            if is_int_type(ptr_assigned.ent()):
                check.violation(ref.ent(), file, ptr_assigned.line(), ptr_assigned.column(), ERR1)
            elif is_void_ptr_type(ptr_assigned.ent()):
                check.violation(ref.ent(), file, ptr_assigned.line(), ptr_assigned.column(), ERR2)
