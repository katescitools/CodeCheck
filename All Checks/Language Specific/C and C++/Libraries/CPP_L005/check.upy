# This script is designed to run with Understand - CodeCheck
# Written by Robby Bennett
# 3-1-2023


import re


ERR1 = 'stdlib function %1 used'

STDLIB = {'stdlib.h', 'cstdlib'}


def ids():
    return ('MISRA04_20.10', 'MISRA08_18-0-2', 'MISRA12_21.7', 'CPP_L005')


def name(id):
    return {
        'MISRA04_20.10': '''Published Standards/MISRA-C 2004/\
20.10 The library functions atof, atoi and atol from library &lt;stdlib.h&gt;\
 shall not be used''',
        'MISRA08_18-0-2': '''Published Standards/MISRA-C++ 2008/\
18-0-2 The library functions atof, atoi and atol from library &lt;cstdlib&gt;\
 shall not be used''',
        'MISRA12_21.7': '''Published Standards/MISRA C 2012/\
21.7 The atof, atoi, atol and atoll functions of &lt;stdlib.h&gt; shall not be\
 used''',
        'CPP_L005': '''All Checks/Language Specific/C and C++/Libraries/\
Avoid atof, atoi, atol, and atoll from &lt;cstdlib&gt; or &lt;stdlib.h&gt;\
''',
    }[id]


def detailed_description(id):
    return {
        'MISRA04_20.10': '''\
<p>
These functions have undefined behaviour associated with them when the string
cannot be converted.
</p>
''',
        'MISRA08_18-0-2': '''\
<p><b>Rationale</b></p>

<p>
These functions have <i>undefined behaviour</i> associated with them when the
string cannot be converted.
</p>

<p><b>Example</b></p>

<pre>
  #include &lt;cstdlib&gt;
  int32_t f ( const char_t * numstr )
  {
    return atoi ( numstr ); // Non-compliant
  }
</pre>
''',
        'MISRA12_21.7': '''\
<p><b>Amplification</b></p>

<p>
The identifiers <i>atof</i>, <i>atoi</i>, <i>atol</i> and, for C99 only
<i>atoll</i>, shall not be used and no macro with one of these names shall be
expanded.
</p>

<p><b>Rationale</b></p>

<p>
These functions have undefined behaviour associated with them when the string
cannot be converted.
</p>
''',
        'CPP_L005': '''\
<p><b>Amplification</b></p>

<p>
The identifiers <i>atof</i>, <i>atoi</i>, <i>atol</i> and, for C99 only
<i>atoll</i>, shall not be used and no macro with one of these names shall be
expanded.
</p>

<p><b>Rationale</b></p>

<p>
These functions have undefined behaviour associated with them when the string
cannot be converted.
</p>
''',
    }[id]


def test_entity(file):
    return file.kind().check('Code File, Header File')


def define_options(check):
    atollNotAllowed = {'MISRA12_21.7', 'CPP_L005'}
    check.options().checkbox('atollNotAllowed', 'Violation for atoll', check.id() in atollNotAllowed)
    check.options().checkbox('oneViolation', 'Limit one violation per file', False)
    check.options().checkbox('onlyIfStdlib', 'Violations only if stdlib is included', True)


def test_language(language):
    return language == 'C++'


def report_info(id):
    return {
        'MISRA04_20.10': {
            'Category':   'Required',
        },
        'MISRA08_18-0-2': {
            'Category':   'Required',
        },
        'MISRA12_21.7': {
            'Category':   'Required',
        },
    }[id]


def stdlibIncluded(file, visited):
    # Base case: visited already before this recursion
    if file in includeCache:
        return includeCache[file]

    # Base case: visited already during this recursion
    if file in visited:
        return False
    visited.add(file)

    # Base case: match found
    if file.name() in STDLIB:
        includeCache[file] = True
        return True

    # Recurse
    for includedFile in file.ents('Include'):
        if stdlibIncluded(includedFile, visited):
            includeCache[includedFile] = True
            return True

    # Not included
    includeCache[file] = False
    return False


def check(check, file):
    global fnNotAllowed, oneViolation, onlyIfStdlib, includeCache
    if 'fnNotAllowed' not in globals():
        # Options
        fnNotAllowed = {'atof', 'atoi', 'atol'}
        if check.options().lookup('atollNotAllowed'):
            fnNotAllowed.add('atoll')
        oneViolation = check.options().lookup('oneViolation')
        onlyIfStdlib = check.options().lookup('onlyIfStdlib')

        # Cache
        includeCache = dict()

    refsUsed = set()

    # Each reference to an unresolved function
    for fnRef in file.filerefs('', 'Unresolved Function'):
        fnEnt = fnRef.ent()

        # Skip if name is allowed
        if fnEnt.name() not in fnNotAllowed:
            continue

        # Skip if stdlib is not included
        if onlyIfStdlib and not stdlibIncluded(file, set()):
            continue

        # Skip if a violation was already made for a ref of the same ent here
        refKey = str(fnEnt.id()) + ':' + str(fnRef.line()) + ':' + str(fnRef.column())
        if refKey in refsUsed:
            continue
        refsUsed.add(refKey)

        check.violation(fnEnt, file, fnRef.line(), fnRef.column(), ERR1, fnEnt.name())
        if oneViolation:
            break
