# This script is designed to run with Understand - CodeCheck
# Rewritten by Robby Bennett
# 2-27-23


import re


ERR1 = 'Overloaded function template explicitly specialized: %1'


def ids():
    return ('MISRA08_14-8-1', 'CPP_F017')


def name(id):
    return {
        'MISRA08_14-8-1': 'Published Standards/MISRA-C++ 2008/\
14-8-1 Overloaded function templates shall not be explicitly specialized',
        'CPP_F017': 'All Checks/Language Specific/C and C++/Functions/\
Overloaded function templates shall not be explicitly specialized',
    }[id]


def detailed_description():
    return '''\
<p><b>Rationale</b></p>

<p>
Explicit specializations will be considered only after overload resolution has
chosen a best match from the set of primary function templates. This may be
inconsistent with developer expectations.
</p>

<p><b>Example</b></p>

<pre>
template &lt;typename T&gt; void f ( T );  // overload Example 1
template &lt;typename T&gt; void f ( T* ); // overload Example 2
template &lt;&gt; void f&lt;int32_t*&gt; ( int32_t* ); // explicit specialization of
                                           // Example 1
void b ( int32_t * i )
{
  f ( i ); // Non-compliant
           // - Calls Example 2, f&lt;int32_t*&gt;
}
</pre>

<p>
Where a template is not overloaded with other templates, or is overloaded with
non-template functions then it can be explicitly specialized, as it is
consistent with developer expectation that the explicit specializations will
only be considered if that <i>primary template</i> is chosen.
</p>

<pre>
template &lt;typename T&gt; void f ( T );        // Example 1
template &lt;&gt; void f&lt;int32_t*&gt; ( int32_t* ); // Example 2
void b ( int32_t * i )
{
 f ( i ); // Compliant
          // - Calls Example 2, f&lt;int32_t*&gt;
}
</pre>
'''


def test_language(language):
    return language == 'C++'


def test_entity(file):
    return file.kind().check('Code File, Header File')


def test_global():
    return False


def check(check, file):
    # Create a dictionary of all declared/defined non-template functions
    functionsList = file.filerefs('Define, Declare', 'Function ~Template', False)
    if not functionsList:
        return
    # { name: firstRef, ... }
    functions = {}
    for funRef in functionsList:
        funEnt = funRef.ent()
        if funEnt.name() not in functions:
            functions[funEnt.name()] = funRef

    # Create a list of all declared/defined template functions
    templateFunctions = file.filerefs('Define, Declare', 'Function Template', False)

    # Loop through each template
    previousName = None
    for templateRef in templateFunctions:
        templateName = templateRef.ent().name()

        # Check each element with the one before
        if previousName == templateName and templateName in functions:
            funRef = functions[templateName]
            funEnt = funRef.ent()

            # Error if function name matches template
            check.violation(funEnt, file, funRef.line(), funRef.column(), ERR1, funEnt.name())

        previousName = templateName
