# This script is designed to run with Understand - CodeCheck
# Written by Robby Bennett
# 3-14-23


ERR1 = 'The # token is not immediately followed by a preprocessing token: %1'
ERR2 = 'The # token is not immediately followed by a preprocessing token'


def ids():
    return ('MISRA08_16-0-8', 'M16-0-8', 'CPP_PR036')


def name(id):
    return {
        'MISRA08_16-0-8': '''Published Standards/MISRA-C++ 2008/\
16-0-8 # Token Immediately Followed by a Preprocessor Directive''',
        'M16-0-8': '''Published Standards/AUTOSAR/\
# Token Immediately Followed by a Preprocessor Directive''',
        'CPP_PR036': '''All Checks/Language Specific/C and C++/Preprocessor/\
# Token Immediately Followed by a Preprocessor Directive''',
    }[id]


def detailed_description():
    return '''\
<p><b>Rule</b></p>

<p>
If the # token appears as the first token on a line, then it shall be
immediately followed by a preprocessing token.
</p>

<p><b>Rationale</b></p>

<p>
When a section of source code is excluded by preprocessor directives, the
content of each excluded statement is ignored until a <i>#else</i>, <i>#elif</i>
or <i>#endif</i> directive is encountered (depending on the context). If one of
these excluded directives is badly formed, it may be ignored without warning by
a compiler with unexpected consequences.
</p>

<p>
The requirement of this rule is that all preprocessor directives shall be
syntactically valid even when they occur within an excluded block of code.
</p>

<p>
In particular, ensure that <i>#else</i> and <i>#endif</i> directives are not
followed by any characters other than white-space. Compilers are not always
consistent in enforcing this requirement.
</p>

<p><b>Example</b></p>

<pre>
#define AAA 2
int32_t foo(void)
{
   int32_t x = 0;
   ...
#ifndef AAA
   x = 1;
#else1              // Non-compliant
   x = AAA;
#endif
   ...
   return x;
}
</pre>
'''


def report_info(id):
    return {
        'MISRA08_16-0-8': {
            'Category': 'Required',
        },
        'M16-0-8': {
            'Automation': 'Automated',
            'Category':   'Required',
        },
    }[id]


def test_entity(file):
    return file.kind().check('Code File, Header File')


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def define_options(check):
    check.options().text('others', 'Other preprocessor directives (whitespace-separated)', '')


def check(check, file):
    global otherDirectives
    if 'otherDirectives' not in globals():
        otherDirectives = {'elifdef', 'elifndef', 'import', 'warning'}
        otherDirectives.update(check.options().lookup('others').split())

    lexer = file.lexer(False)

    if not lexer:
        return

    line = 0
    lex = lexer.first()

    while lex:
        directiveExpected = lex.text() == '#' and lex.token() == 'Preprocessor' and lex.line_begin() != line

        prev = lex
        line = prev.line_begin()
        lex = lex.next(ignore_whitespace=True, ignore_comments=True)

        # Skip if a preprocessor directive isn't expected
        if not directiveExpected:
            continue

        # Violation for an incorrect token
        if lex:
            # Skip if this token is a preprocessor directive
            if lex.token() == 'Preprocessor' or lex.text() in otherDirectives:
                continue
            check.violation(None, file, lex.line_begin(), lex.column_begin(), ERR1, lex.text())

        # Violation for a missing token
        else:
            check.violation(None, file, prev.line_begin(), prev.column_begin(), ERR2)
